import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/crocks/core/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/crocks/core/isFunction.js"(exports, module) {
    function isFunction(fn) {
      return typeof fn === "function";
    }
    module.exports = isFunction;
  }
});

// node_modules/crocks/core/curry.js
var require_curry = __commonJS({
  "node_modules/crocks/core/curry.js"(exports, module) {
    var isFunction = require_isFunction();
    var CURRY_SYMB = "@@crocks/curried";
    function applyCurry(fn, arg) {
      if (!isFunction(fn)) {
        return fn;
      }
      return fn.length > 1 ? fn.bind(null, arg) : fn.call(null, arg);
    }
    function curry(fn) {
      if (fn[CURRY_SYMB]) {
        return fn;
      }
      function curried() {
        var xs = [], len = arguments.length;
        while (len--)
          xs[len] = arguments[len];
        var args = xs.length ? xs : [void 0];
        if (args.length < fn.length) {
          return curry(Function.bind.apply(fn, [null].concat(args)));
        }
        var val = args.length === fn.length ? fn.apply(null, args) : args.reduce(applyCurry, fn);
        if (isFunction(val)) {
          return curry(val);
        }
        return val;
      }
      Object.defineProperty(curried, CURRY_SYMB, {
        enumerable: false,
        writable: false,
        value: true
      });
      return curried;
    }
    module.exports = curry;
  }
});

// node_modules/crocks/combinators/applyTo.js
var require_applyTo = __commonJS({
  "node_modules/crocks/combinators/applyTo.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function applyTo(x, f) {
      if (!isFunction(f)) {
        throw new TypeError("applyTo: Function required for second argument");
      }
      return f(x);
    }
    module.exports = curry(applyTo);
  }
});

// node_modules/crocks/combinators/compose2.js
var require_compose2 = __commonJS({
  "node_modules/crocks/combinators/compose2.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function compose2(f, g, h, x, y) {
      if (!isFunction(f) || !isFunction(g) || !isFunction(h)) {
        throw new TypeError("compose2: First, second and third arguments must be functions");
      }
      return curry(f)(g(x), h(y));
    }
    module.exports = curry(compose2);
  }
});

// node_modules/crocks/core/compose.js
var require_compose = __commonJS({
  "node_modules/crocks/core/compose.js"(exports, module) {
    function compose(f, g) {
      return function(x) {
        return f(g(x));
      };
    }
    module.exports = compose;
  }
});

// node_modules/crocks/combinators/composeB.js
var require_composeB = __commonJS({
  "node_modules/crocks/combinators/composeB.js"(exports, module) {
    var compose = require_compose();
    var curry = require_curry();
    var isFunction = require_isFunction();
    function composeB(f, g) {
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "composeB: Functions required for first two arguments"
        );
      }
      return compose(f, g);
    }
    module.exports = curry(composeB);
  }
});

// node_modules/crocks/combinators/constant.js
var require_constant = __commonJS({
  "node_modules/crocks/combinators/constant.js"(exports, module) {
    var curry = require_curry();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    module.exports = curry(constant);
  }
});

// node_modules/crocks/combinators/converge.js
var require_converge = __commonJS({
  "node_modules/crocks/combinators/converge.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function converge(f, g, h, x) {
      if (!isFunction(f) || !isFunction(g) || !isFunction(h)) {
        throw new TypeError("converge: Functions required for first three arguments");
      }
      return curry(f)(g(x), h(x));
    }
    module.exports = curry(converge);
  }
});

// node_modules/crocks/combinators/flip.js
var require_flip = __commonJS({
  "node_modules/crocks/combinators/flip.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function flip(f, x, y) {
      if (!isFunction(f)) {
        throw new TypeError(
          "flip: Function required for first argument"
        );
      }
      return curry(f)(y, x);
    }
    module.exports = curry(flip);
  }
});

// node_modules/crocks/combinators/identity.js
var require_identity = __commonJS({
  "node_modules/crocks/combinators/identity.js"(exports, module) {
    var identity = function(x) {
      return x;
    };
    module.exports = identity;
  }
});

// node_modules/crocks/combinators/psi.js
var require_psi = __commonJS({
  "node_modules/crocks/combinators/psi.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function psi(f, g, x, y) {
      if (!isFunction(f) || !isFunction(g)) {
        throw new TypeError("psi: First and second arguments must be functions");
      }
      return curry(f)(g(x), g(y));
    }
    module.exports = curry(psi);
  }
});

// node_modules/crocks/combinators/substitution.js
var require_substitution = __commonJS({
  "node_modules/crocks/combinators/substitution.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function substitution(f, g, x) {
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "substitution: Functions required for first two arguments"
        );
      }
      return curry(f)(x, g(x));
    }
    module.exports = curry(substitution);
  }
});

// node_modules/crocks/combinators/index.js
var require_combinators = __commonJS({
  "node_modules/crocks/combinators/index.js"(exports, module) {
    module.exports = {
      applyTo: require_applyTo(),
      compose2: require_compose2(),
      composeB: require_composeB(),
      constant: require_constant(),
      converge: require_converge(),
      flip: require_flip(),
      identity: require_identity(),
      psi: require_psi(),
      substitution: require_substitution()
    };
  }
});

// node_modules/crocks/core/types.js
var require_types = __commonJS({
  "node_modules/crocks/core/types.js"(exports, module) {
    var _types = {
      "unk": function() {
        return "unknown";
      },
      "All": function() {
        return "All";
      },
      "Any": function() {
        return "Any";
      },
      "Arrow": function() {
        return "Arrow";
      },
      "Assign": function() {
        return "Assign";
      },
      "Async": function() {
        return "Async";
      },
      "Const": function(inner) {
        return "Const(" + inner + ")";
      },
      "Either": function() {
        return "Either";
      },
      "Endo": function() {
        return "Endo";
      },
      "Equiv": function() {
        return "Equiv";
      },
      "First": function() {
        return "First";
      },
      "Identity": function() {
        return "Identity";
      },
      "IO": function() {
        return "IO";
      },
      "Last": function() {
        return "Last";
      },
      "List": function() {
        return "List";
      },
      "Max": function() {
        return "Max";
      },
      "Maybe": function() {
        return "Maybe";
      },
      "Min": function() {
        return "Min";
      },
      "Pair": function() {
        return "Pair";
      },
      "Pred": function() {
        return "Pred";
      },
      "Prod": function() {
        return "Prod";
      },
      "Reader": function() {
        return "Reader";
      },
      "Result": function() {
        return "Result";
      },
      "Star": function() {
        return "Star";
      },
      "State": function() {
        return "State";
      },
      "Sum": function() {
        return "Sum";
      },
      "Tuple": function(n) {
        return n + "-Tuple";
      },
      "Unit": function() {
        return "Unit";
      },
      "Writer": function() {
        return "Writer";
      }
    };
    var type = function(type2) {
      return _types[type2] || _types["unk"];
    };
    var proxy = function(t, ctx) {
      return { type: function() {
        return type(t)(ctx);
      } };
    };
    var typeFn = function(t, ver, ctx) {
      var typeStr = type(t)(ctx);
      return "crocks/" + typeStr + "@" + (ver || 0);
    };
    module.exports = {
      proxy,
      type,
      typeFn
    };
  }
});

// node_modules/crocks/core/type.js
var require_type = __commonJS({
  "node_modules/crocks/core/type.js"(exports, module) {
    var isFunction = require_isFunction();
    function type(x) {
      if (x) {
        if (isFunction(x.type)) {
          return x.type();
        }
      }
      return {}.toString.call(x).slice(8, -1);
    }
    module.exports = type;
  }
});

// node_modules/crocks/core/isSameType.js
var require_isSameType = __commonJS({
  "node_modules/crocks/core/isSameType.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    var type = require_type();
    function isSameType(x, y) {
      var tX = type(x);
      var tY = type(y);
      return tX === tY || isFunction(x) && x.name === tY || isFunction(y) && y.name === tX;
    }
    module.exports = curry(isSameType);
  }
});

// node_modules/crocks/core/isPredOrFunc.js
var require_isPredOrFunc = __commonJS({
  "node_modules/crocks/core/isPredOrFunc.js"(exports, module) {
    var Pred = require_types().proxy("Pred");
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var isPredOrFunc = function(predOrFunc) {
      return isFunction(predOrFunc) || isSameType(Pred, predOrFunc);
    };
    module.exports = isPredOrFunc;
  }
});

// node_modules/crocks/core/predOrFunc.js
var require_predOrFunc = __commonJS({
  "node_modules/crocks/core/predOrFunc.js"(exports, module) {
    var isFunction = require_isFunction();
    function predOrFunc(pred, x) {
      if (isFunction(pred)) {
        return pred(x);
      }
      return pred.runWith(x);
    }
    module.exports = predOrFunc;
  }
});

// node_modules/crocks/logic/and.js
var require_and = __commonJS({
  "node_modules/crocks/logic/and.js"(exports, module) {
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var predOrFunc = require_predOrFunc();
    function and(f, g) {
      if (!(isPredOrFunc(f) && isPredOrFunc(g))) {
        throw new TypeError(
          "and: Preds or predicate functions required for first two arguments"
        );
      }
      return function(x) {
        return !!(predOrFunc(f, x) && predOrFunc(g, x));
      };
    }
    module.exports = curry(and);
  }
});

// node_modules/crocks/logic/ifElse.js
var require_ifElse = __commonJS({
  "node_modules/crocks/logic/ifElse.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isPredOrFunc = require_isPredOrFunc();
    var predOrFunc = require_predOrFunc();
    function ifElse(pred, f, g) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "ifElse: Pred or predicate function required for first argument"
        );
      }
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "ifElse: Functions required for second and third arguments"
        );
      }
      return function(x) {
        return predOrFunc(pred, x) ? f(x) : g(x);
      };
    }
    module.exports = curry(ifElse);
  }
});

// node_modules/crocks/logic/implies.js
var require_implies = __commonJS({
  "node_modules/crocks/logic/implies.js"(exports, module) {
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var predOrFunc = require_predOrFunc();
    function implies(p, q) {
      if (!(isPredOrFunc(p) && isPredOrFunc(q))) {
        throw new TypeError(
          "implies: Preds or predicate functions required for first two arguments"
        );
      }
      return function(x) {
        return !predOrFunc(p, x) || !!predOrFunc(q, x);
      };
    }
    module.exports = curry(implies);
  }
});

// node_modules/crocks/logic/not.js
var require_not = __commonJS({
  "node_modules/crocks/logic/not.js"(exports, module) {
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var predOrFunc = require_predOrFunc();
    function not(pred, x) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "not: Pred or predicate function required for first argument"
        );
      }
      return !predOrFunc(pred, x);
    }
    module.exports = curry(not);
  }
});

// node_modules/crocks/logic/or.js
var require_or = __commonJS({
  "node_modules/crocks/logic/or.js"(exports, module) {
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var predOrFunc = require_predOrFunc();
    function or(f, g) {
      if (!(isPredOrFunc(f) && isPredOrFunc(g))) {
        throw new TypeError(
          "or: Preds or predicate functions required for first two arguments"
        );
      }
      return function(x) {
        return !!(predOrFunc(f, x) || predOrFunc(g, x));
      };
    }
    module.exports = curry(or);
  }
});

// node_modules/crocks/logic/unless.js
var require_unless = __commonJS({
  "node_modules/crocks/logic/unless.js"(exports, module) {
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var isFunction = require_isFunction();
    var predOrFunc = require_predOrFunc();
    function unless(pred, f) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "unless: Pred or predicate function required for first argument"
        );
      }
      if (!isFunction(f)) {
        throw new TypeError(
          "unless: Function required for second argument"
        );
      }
      return function(x) {
        return !predOrFunc(pred, x) ? f(x) : x;
      };
    }
    module.exports = curry(unless);
  }
});

// node_modules/crocks/logic/when.js
var require_when = __commonJS({
  "node_modules/crocks/logic/when.js"(exports, module) {
    var curry = require_curry();
    var predOrFunc = require_predOrFunc();
    var isPredOrFunc = require_isPredOrFunc();
    var isFunction = require_isFunction();
    function when(pred, f) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "when: Pred or predicate function required for first argument"
        );
      }
      if (!isFunction(f)) {
        throw new TypeError(
          "when: Function required for second argument"
        );
      }
      return function(x) {
        return predOrFunc(pred, x) ? f(x) : x;
      };
    }
    module.exports = curry(when);
  }
});

// node_modules/crocks/logic/index.js
var require_logic = __commonJS({
  "node_modules/crocks/logic/index.js"(exports, module) {
    module.exports = {
      and: require_and(),
      ifElse: require_ifElse(),
      implies: require_implies(),
      not: require_not(),
      or: require_or(),
      unless: require_unless(),
      when: require_when()
    };
  }
});

// node_modules/crocks/core/isDefined.js
var require_isDefined = __commonJS({
  "node_modules/crocks/core/isDefined.js"(exports, module) {
    function isDefined(x) {
      return x !== void 0;
    }
    module.exports = isDefined;
  }
});

// node_modules/crocks/core/isObject.js
var require_isObject = __commonJS({
  "node_modules/crocks/core/isObject.js"(exports, module) {
    var toString = Object.prototype.toString;
    function isObject(x) {
      return !!x && toString.call(x) === "[object Object]";
    }
    module.exports = isObject;
  }
});

// node_modules/crocks/core/flNames.js
var require_flNames = __commonJS({
  "node_modules/crocks/core/flNames.js"(exports, module) {
    module.exports = {
      alt: "fantasy-land/alt",
      bimap: "fantasy-land/bimap",
      chain: "fantasy-land/chain",
      compose: "fantasy-land/compose",
      concat: "fantasy-land/concat",
      contramap: "fantasy-land/contramap",
      empty: "fantasy-land/empty",
      equals: "fantasy-land/equals",
      extend: "fantasy-land/extend",
      filter: "fantasy-land/filter",
      id: "fantasy-land/id",
      map: "fantasy-land/map",
      of: "fantasy-land/of",
      promap: "fantasy-land/promap",
      reduce: "fantasy-land/reduce",
      zero: "fantasy-land/zero"
    };
  }
});

// node_modules/crocks/core/hasAlg.js
var require_hasAlg = __commonJS({
  "node_modules/crocks/core/hasAlg.js"(exports, module) {
    var isFunction = require_isFunction();
    var fl = require_flNames();
    var check = function(alg, m) {
      return isFunction(m[fl[alg]]) || isFunction(m[alg]);
    };
    var checkImpl = function(alg, m) {
      return isFunction(m["@@implements"]) && !!m["@@implements"](alg);
    };
    var hasAlg = function(alg, m) {
      return !!m && (check(alg, m) || checkImpl(alg, m));
    };
    module.exports = hasAlg;
  }
});

// node_modules/crocks/core/isString.js
var require_isString = __commonJS({
  "node_modules/crocks/core/isString.js"(exports, module) {
    function isString(x) {
      return typeof x === "string";
    }
    module.exports = isString;
  }
});

// node_modules/crocks/core/isSemigroup.js
var require_isSemigroup = __commonJS({
  "node_modules/crocks/core/isSemigroup.js"(exports, module) {
    var isString = require_isString();
    var hasAlg = require_hasAlg();
    function isSemigroup(m) {
      return isString(m) || !!m && hasAlg("concat", m);
    }
    module.exports = isSemigroup;
  }
});

// node_modules/crocks/core/isMonoid.js
var require_isMonoid = __commonJS({
  "node_modules/crocks/core/isMonoid.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isSemigroup = require_isSemigroup();
    function isMonoid(m) {
      return isSemigroup(m) && (hasAlg("empty", m) || hasAlg("empty", m.constructor));
    }
    module.exports = isMonoid;
  }
});

// node_modules/crocks/core/isSame.js
var require_isSame = __commonJS({
  "node_modules/crocks/core/isSame.js"(exports, module) {
    function isSame(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      }
      return x !== x && y !== y;
    }
    module.exports = isSame;
  }
});

// node_modules/crocks/core/equals.js
var require_equals = __commonJS({
  "node_modules/crocks/core/equals.js"(exports, module) {
    var isSameType = require_isSameType();
    var isSame = require_isSame();
    var hasAlg = require_hasAlg();
    var type = require_type();
    var fl = require_flNames();
    var comp = function(a, b) {
      return a.valueOf() === b.valueOf();
    };
    var strats = {
      "Array": function(a, b) {
        return a.length === b.length && deepEquals(a, b);
      },
      "Date": function(a, b) {
        return isSame(a.valueOf(), b.valueOf());
      },
      "Error": function(a, b) {
        return a.name === b.name && a.message === b.message;
      },
      "Object": function(a, b) {
        return Object.keys(a).length === Object.keys(b).length && deepEquals(a, b);
      },
      "RegExp": function(a, b) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.global === b.global && a.multiline === b.multiline && a.unicode === b.unicode;
      }
    };
    function deepEquals(a, b) {
      for (var key in a) {
        if (!equals(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    function equals(a, b) {
      if (isSame(a, b)) {
        return true;
      }
      if (!isSameType(a, b)) {
        return false;
      }
      if (hasAlg("equals", a)) {
        return (b[fl.equals] || b.equals).call(b, a);
      }
      return (strats[type(a)] || comp)(a, b);
    }
    module.exports = equals;
  }
});

// node_modules/crocks/core/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/crocks/core/isEmpty.js"(exports, module) {
    var isObject = require_isObject();
    var isMonoid = require_isMonoid();
    var equals = require_equals();
    var fl = require_flNames();
    function isEmpty(x) {
      if (isMonoid(x)) {
        var empty = x.constructor[fl["empty"]] || x.constructor["empty"] || x["empty"];
        return equals(x, empty());
      }
      if (isObject(x)) {
        return !Object.keys(x).length;
      }
      if (x && x.length !== void 0) {
        return !x.length;
      }
      return true;
    }
    module.exports = isEmpty;
  }
});

// node_modules/crocks/core/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/crocks/core/isNumber.js"(exports, module) {
    function isNumber(x) {
      return typeof x === "number" && !isNaN(x);
    }
    module.exports = isNumber;
  }
});

// node_modules/crocks/core/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/crocks/core/isInteger.js"(exports, module) {
    var isNumber = require_isNumber();
    function isInteger(x) {
      return isNumber(x) && isFinite(x) && Math.floor(x) === x;
    }
    module.exports = isInteger;
  }
});

// node_modules/crocks/core/isNil.js
var require_isNil = __commonJS({
  "node_modules/crocks/core/isNil.js"(exports, module) {
    function isNil(x) {
      return x == null || x !== x;
    }
    module.exports = isNil;
  }
});

// node_modules/crocks/predicates/hasProp.js
var require_hasProp = __commonJS({
  "node_modules/crocks/predicates/hasProp.js"(exports, module) {
    var curry = require_curry();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    function hasProp(key, x) {
      if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
        throw new TypeError(
          "hasProp: Non-empty String or Integer required for first argument"
        );
      }
      if (isNil(x)) {
        return false;
      }
      return isDefined(x[key]);
    }
    module.exports = curry(hasProp);
  }
});

// node_modules/crocks/core/isFoldable.js
var require_isFoldable = __commonJS({
  "node_modules/crocks/core/isFoldable.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isFoldable(m) {
      return !!m && hasAlg("reduce", m);
    }
    module.exports = isFoldable;
  }
});

// node_modules/crocks/predicates/hasProps.js
var require_hasProps = __commonJS({
  "node_modules/crocks/predicates/hasProps.js"(exports, module) {
    var curry = require_curry();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isFoldable = require_isFoldable();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    var err = "hasProps: First argument must be a Foldable of Non-empty Strings or Integers";
    var isKeyValid = function(key) {
      return isString(key) && !isEmpty(key) || isInteger(key);
    };
    var hasKey = function(obj) {
      return function(key) {
        if (!isKeyValid(key)) {
          throw new TypeError(err);
        }
        return isDefined(obj[key]);
      };
    };
    var every = function(fn) {
      return function(acc, x) {
        return (acc === null ? true : acc) && fn(x);
      };
    };
    function hasProps(keys, x) {
      if (!isFoldable(keys)) {
        throw new TypeError(err);
      }
      if (isNil(x)) {
        return false;
      }
      var result = keys.reduce(
        every(hasKey(x)),
        null
      );
      return result === null || result;
    }
    module.exports = curry(hasProps);
  }
});

// node_modules/crocks/core/isArray.js
var require_isArray = __commonJS({
  "node_modules/crocks/core/isArray.js"(exports, module) {
    function isArray(x) {
      return Array.isArray(x);
    }
    module.exports = isArray;
  }
});

// node_modules/crocks/predicates/hasPropPath.js
var require_hasPropPath = __commonJS({
  "node_modules/crocks/predicates/hasPropPath.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    function hasPropPath(keys, target) {
      if (!isArray(keys)) {
        throw new TypeError(
          "hasPropPath: Array of Non-empty Strings or Integers required for first argument"
        );
      }
      if (isNil(target)) {
        return false;
      }
      var value = target;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
          throw new TypeError(
            "hasPropPath: Array of Non-empty Strings or Integers required for first argument"
          );
        }
        if (isNil(value)) {
          return false;
        }
        value = value[key];
        if (!isDefined(value)) {
          return false;
        }
      }
      return true;
    }
    module.exports = curry(hasPropPath);
  }
});

// node_modules/crocks/core/isFunctor.js
var require_isFunctor = __commonJS({
  "node_modules/crocks/core/isFunctor.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isFunctor(m) {
      return !!m && hasAlg("map", m);
    }
    module.exports = isFunctor;
  }
});

// node_modules/crocks/core/isAlt.js
var require_isAlt = __commonJS({
  "node_modules/crocks/core/isAlt.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isFunctor = require_isFunctor();
    function isAlt(m) {
      return isFunctor(m) && hasAlg("alt", m);
    }
    module.exports = isAlt;
  }
});

// node_modules/crocks/predicates/isAlt.js
var require_isAlt2 = __commonJS({
  "node_modules/crocks/predicates/isAlt.js"(exports, module) {
    module.exports = require_isAlt();
  }
});

// node_modules/crocks/core/isApply.js
var require_isApply = __commonJS({
  "node_modules/crocks/core/isApply.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isFunctor = require_isFunctor();
    function isApply(m) {
      return isFunctor(m) && hasAlg("ap", m);
    }
    module.exports = isApply;
  }
});

// node_modules/crocks/core/isApplicative.js
var require_isApplicative = __commonJS({
  "node_modules/crocks/core/isApplicative.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isApply = require_isApply();
    function isApplicative(m) {
      return isApply(m) && (hasAlg("of", m) || hasAlg("of", m.constructor));
    }
    module.exports = isApplicative;
  }
});

// node_modules/crocks/core/isPlus.js
var require_isPlus = __commonJS({
  "node_modules/crocks/core/isPlus.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isAlt = require_isAlt();
    function isPlus(m) {
      return isAlt(m) && (hasAlg("zero", m) || hasAlg("zero", m.constructor));
    }
    module.exports = isPlus;
  }
});

// node_modules/crocks/predicates/isAlternative.js
var require_isAlternative = __commonJS({
  "node_modules/crocks/predicates/isAlternative.js"(exports, module) {
    var isApplicative = require_isApplicative();
    var isPlus = require_isPlus();
    function isAlternative(m) {
      return isPlus(m) && isApplicative(m);
    }
    module.exports = isAlternative;
  }
});

// node_modules/crocks/predicates/isApplicative.js
var require_isApplicative2 = __commonJS({
  "node_modules/crocks/predicates/isApplicative.js"(exports, module) {
    module.exports = require_isApplicative();
  }
});

// node_modules/crocks/predicates/isApply.js
var require_isApply2 = __commonJS({
  "node_modules/crocks/predicates/isApply.js"(exports, module) {
    module.exports = require_isApply();
  }
});

// node_modules/crocks/predicates/isArray.js
var require_isArray2 = __commonJS({
  "node_modules/crocks/predicates/isArray.js"(exports, module) {
    module.exports = require_isArray();
  }
});

// node_modules/crocks/core/isBifunctor.js
var require_isBifunctor = __commonJS({
  "node_modules/crocks/core/isBifunctor.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isFunctor = require_isFunctor();
    function isBifunctor(m) {
      return isFunctor(m) && hasAlg("bimap", m);
    }
    module.exports = isBifunctor;
  }
});

// node_modules/crocks/predicates/isBifunctor.js
var require_isBifunctor2 = __commonJS({
  "node_modules/crocks/predicates/isBifunctor.js"(exports, module) {
    module.exports = require_isBifunctor();
  }
});

// node_modules/crocks/core/isBichain.js
var require_isBichain = __commonJS({
  "node_modules/crocks/core/isBichain.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isBichain(m) {
      return hasAlg("bichain", m);
    }
    module.exports = isBichain;
  }
});

// node_modules/crocks/predicates/isBichain.js
var require_isBichain2 = __commonJS({
  "node_modules/crocks/predicates/isBichain.js"(exports, module) {
    module.exports = require_isBichain();
  }
});

// node_modules/crocks/predicates/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/crocks/predicates/isBoolean.js"(exports, module) {
    function isBoolean(x) {
      return typeof x === "boolean";
    }
    module.exports = isBoolean;
  }
});

// node_modules/crocks/core/isSemigroupoid.js
var require_isSemigroupoid = __commonJS({
  "node_modules/crocks/core/isSemigroupoid.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isSemigroupoid(m) {
      return !!m && hasAlg("compose", m);
    }
    module.exports = isSemigroupoid;
  }
});

// node_modules/crocks/predicates/isCategory.js
var require_isCategory = __commonJS({
  "node_modules/crocks/predicates/isCategory.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isSemigroupoid = require_isSemigroupoid();
    function isCategory(m) {
      return isSemigroupoid(m) && (hasAlg("id", m) || hasAlg("id", m.constructor));
    }
    module.exports = isCategory;
  }
});

// node_modules/crocks/core/isChain.js
var require_isChain = __commonJS({
  "node_modules/crocks/core/isChain.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isApply = require_isApply();
    function isChain(m) {
      return isApply(m) && hasAlg("chain", m);
    }
    module.exports = isChain;
  }
});

// node_modules/crocks/predicates/isChain.js
var require_isChain2 = __commonJS({
  "node_modules/crocks/predicates/isChain.js"(exports, module) {
    module.exports = require_isChain();
  }
});

// node_modules/crocks/core/isContravariant.js
var require_isContravariant = __commonJS({
  "node_modules/crocks/core/isContravariant.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isContravariant(m) {
      return !!m && hasAlg("contramap", m);
    }
    module.exports = isContravariant;
  }
});

// node_modules/crocks/predicates/isContravariant.js
var require_isContravariant2 = __commonJS({
  "node_modules/crocks/predicates/isContravariant.js"(exports, module) {
    module.exports = require_isContravariant();
  }
});

// node_modules/crocks/core/isDate.js
var require_isDate = __commonJS({
  "node_modules/crocks/core/isDate.js"(exports, module) {
    function isDate(x) {
      return Object.prototype.toString.apply(x) === "[object Date]" && !isNaN(x.valueOf());
    }
    module.exports = isDate;
  }
});

// node_modules/crocks/predicates/isDate.js
var require_isDate2 = __commonJS({
  "node_modules/crocks/predicates/isDate.js"(exports, module) {
    module.exports = require_isDate();
  }
});

// node_modules/crocks/predicates/isDefined.js
var require_isDefined2 = __commonJS({
  "node_modules/crocks/predicates/isDefined.js"(exports, module) {
    module.exports = require_isDefined();
  }
});

// node_modules/crocks/predicates/isEmpty.js
var require_isEmpty2 = __commonJS({
  "node_modules/crocks/predicates/isEmpty.js"(exports, module) {
    module.exports = require_isEmpty();
  }
});

// node_modules/crocks/core/isExtend.js
var require_isExtend = __commonJS({
  "node_modules/crocks/core/isExtend.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isFunctor = require_isFunctor();
    function isExtend(m) {
      return isFunctor(m) && hasAlg("extend", m);
    }
    module.exports = isExtend;
  }
});

// node_modules/crocks/predicates/isExtend.js
var require_isExtend2 = __commonJS({
  "node_modules/crocks/predicates/isExtend.js"(exports, module) {
    module.exports = require_isExtend();
  }
});

// node_modules/crocks/predicates/isFalse.js
var require_isFalse = __commonJS({
  "node_modules/crocks/predicates/isFalse.js"(exports, module) {
    function isFalse(x) {
      return x === false;
    }
    module.exports = isFalse;
  }
});

// node_modules/crocks/predicates/isFalsy.js
var require_isFalsy = __commonJS({
  "node_modules/crocks/predicates/isFalsy.js"(exports, module) {
    function isFalsy(x) {
      return !x;
    }
    module.exports = isFalsy;
  }
});

// node_modules/crocks/predicates/isFoldable.js
var require_isFoldable2 = __commonJS({
  "node_modules/crocks/predicates/isFoldable.js"(exports, module) {
    module.exports = require_isFoldable();
  }
});

// node_modules/crocks/predicates/isFunction.js
var require_isFunction2 = __commonJS({
  "node_modules/crocks/predicates/isFunction.js"(exports, module) {
    module.exports = require_isFunction();
  }
});

// node_modules/crocks/predicates/isFunctor.js
var require_isFunctor2 = __commonJS({
  "node_modules/crocks/predicates/isFunctor.js"(exports, module) {
    module.exports = require_isFunctor();
  }
});

// node_modules/crocks/predicates/isInteger.js
var require_isInteger2 = __commonJS({
  "node_modules/crocks/predicates/isInteger.js"(exports, module) {
    module.exports = require_isInteger();
  }
});

// node_modules/crocks/core/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/crocks/core/isIterable.js"(exports, module) {
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    function isIterable(iterable) {
      return !isNil(iterable) && isFunction(iterable[Symbol.iterator]);
    }
    module.exports = isIterable;
  }
});

// node_modules/crocks/predicates/isIterable.js
var require_isIterable2 = __commonJS({
  "node_modules/crocks/predicates/isIterable.js"(exports, module) {
    module.exports = require_isIterable();
  }
});

// node_modules/crocks/core/isMap.js
var require_isMap = __commonJS({
  "node_modules/crocks/core/isMap.js"(exports, module) {
    function isMap(x) {
      return x instanceof Map;
    }
    module.exports = isMap;
  }
});

// node_modules/crocks/predicates/isMap.js
var require_isMap2 = __commonJS({
  "node_modules/crocks/predicates/isMap.js"(exports, module) {
    module.exports = require_isMap();
  }
});

// node_modules/crocks/core/isMonad.js
var require_isMonad = __commonJS({
  "node_modules/crocks/core/isMonad.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isApplicative = require_isApplicative();
    function isMonad(m) {
      return isApplicative(m) && hasAlg("chain", m);
    }
    module.exports = isMonad;
  }
});

// node_modules/crocks/predicates/isMonad.js
var require_isMonad2 = __commonJS({
  "node_modules/crocks/predicates/isMonad.js"(exports, module) {
    module.exports = require_isMonad();
  }
});

// node_modules/crocks/predicates/isMonoid.js
var require_isMonoid2 = __commonJS({
  "node_modules/crocks/predicates/isMonoid.js"(exports, module) {
    module.exports = require_isMonoid();
  }
});

// node_modules/crocks/predicates/isNil.js
var require_isNil2 = __commonJS({
  "node_modules/crocks/predicates/isNil.js"(exports, module) {
    module.exports = require_isNil();
  }
});

// node_modules/crocks/predicates/isNumber.js
var require_isNumber2 = __commonJS({
  "node_modules/crocks/predicates/isNumber.js"(exports, module) {
    module.exports = require_isNumber();
  }
});

// node_modules/crocks/predicates/isObject.js
var require_isObject2 = __commonJS({
  "node_modules/crocks/predicates/isObject.js"(exports, module) {
    module.exports = require_isObject();
  }
});

// node_modules/crocks/predicates/isPlus.js
var require_isPlus2 = __commonJS({
  "node_modules/crocks/predicates/isPlus.js"(exports, module) {
    module.exports = require_isPlus();
  }
});

// node_modules/crocks/core/isProfunctor.js
var require_isProfunctor = __commonJS({
  "node_modules/crocks/core/isProfunctor.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isContravariant = require_isContravariant();
    var isFunctor = require_isFunctor();
    function isProfunctor(m) {
      return isContravariant(m) && isFunctor(m) && hasAlg("promap", m);
    }
    module.exports = isProfunctor;
  }
});

// node_modules/crocks/predicates/isProfunctor.js
var require_isProfunctor2 = __commonJS({
  "node_modules/crocks/predicates/isProfunctor.js"(exports, module) {
    module.exports = require_isProfunctor();
  }
});

// node_modules/crocks/core/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/crocks/core/isPromise.js"(exports, module) {
    var isFunction = require_isFunction();
    function isPromise(p) {
      return !!p && isFunction(p.then) && isFunction(p.catch);
    }
    module.exports = isPromise;
  }
});

// node_modules/crocks/predicates/isPromise.js
var require_isPromise2 = __commonJS({
  "node_modules/crocks/predicates/isPromise.js"(exports, module) {
    module.exports = require_isPromise();
  }
});

// node_modules/crocks/predicates/isSame.js
var require_isSame2 = __commonJS({
  "node_modules/crocks/predicates/isSame.js"(exports, module) {
    var curry = require_curry();
    var isSame = require_isSame();
    module.exports = curry(isSame);
  }
});

// node_modules/crocks/predicates/isSameType.js
var require_isSameType2 = __commonJS({
  "node_modules/crocks/predicates/isSameType.js"(exports, module) {
    module.exports = require_isSameType();
  }
});

// node_modules/crocks/predicates/isSemigroup.js
var require_isSemigroup2 = __commonJS({
  "node_modules/crocks/predicates/isSemigroup.js"(exports, module) {
    module.exports = require_isSemigroup();
  }
});

// node_modules/crocks/predicates/isSemigroupoid.js
var require_isSemigroupoid2 = __commonJS({
  "node_modules/crocks/predicates/isSemigroupoid.js"(exports, module) {
    module.exports = require_isSemigroupoid();
  }
});

// node_modules/crocks/predicates/isSetoid.js
var require_isSetoid = __commonJS({
  "node_modules/crocks/predicates/isSetoid.js"(exports, module) {
    var hasAlg = require_hasAlg();
    function isSetoid(m) {
      return !!m && hasAlg("equals", m);
    }
    module.exports = isSetoid;
  }
});

// node_modules/crocks/predicates/isString.js
var require_isString2 = __commonJS({
  "node_modules/crocks/predicates/isString.js"(exports, module) {
    module.exports = require_isString();
  }
});

// node_modules/crocks/core/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/crocks/core/isSymbol.js"(exports, module) {
    function isSymbol(x) {
      return typeof x === "symbol";
    }
    module.exports = isSymbol;
  }
});

// node_modules/crocks/predicates/isSymbol.js
var require_isSymbol2 = __commonJS({
  "node_modules/crocks/predicates/isSymbol.js"(exports, module) {
    module.exports = require_isSymbol();
  }
});

// node_modules/crocks/predicates/isTraversable.js
var require_isTraversable = __commonJS({
  "node_modules/crocks/predicates/isTraversable.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isFunctor = require_isFunctor();
    function isTraversable(m) {
      return isFunctor(m) && hasAlg("traverse", m);
    }
    module.exports = isTraversable;
  }
});

// node_modules/crocks/predicates/isTrue.js
var require_isTrue = __commonJS({
  "node_modules/crocks/predicates/isTrue.js"(exports, module) {
    function isTrue(x) {
      return x === true;
    }
    module.exports = isTrue;
  }
});

// node_modules/crocks/predicates/isTruthy.js
var require_isTruthy = __commonJS({
  "node_modules/crocks/predicates/isTruthy.js"(exports, module) {
    function isTruthy(x) {
      return !!x;
    }
    module.exports = isTruthy;
  }
});

// node_modules/crocks/predicates/pathEq.js
var require_pathEq = __commonJS({
  "node_modules/crocks/predicates/pathEq.js"(exports, module) {
    var curry = require_curry();
    var equals = require_equals();
    var isArray = require_isArray();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    var err = function(name) {
      return name + ": First argument must be an Array of non-empty Strings or Integers";
    };
    function fn(name) {
      function pathEq2(keys, value, target) {
        if (!isArray(keys)) {
          throw new TypeError(err(name));
        }
        if (isNil(target)) {
          return false;
        }
        var acc = target;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
            throw new TypeError(err(name));
          }
          if (isNil(acc)) {
            return false;
          }
          acc = acc[key];
          if (!isDefined(acc)) {
            return false;
          }
        }
        return equals(acc, value);
      }
      return curry(pathEq2);
    }
    var pathEq = fn("pathEq");
    pathEq.origFn = fn;
    module.exports = pathEq;
  }
});

// node_modules/crocks/predicates/pathSatisfies.js
var require_pathSatisfies = __commonJS({
  "node_modules/crocks/predicates/pathSatisfies.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isPredOrFunc = require_isPredOrFunc();
    var isString = require_isString();
    var predOrFunc = require_predOrFunc();
    var err = function(name) {
      return name + ": First argument must be an Array of non-empty Strings or Integers";
    };
    function fn(name) {
      function pathSatisfies2(keys, pred, x) {
        if (!isArray(keys)) {
          throw new TypeError(err(name));
        }
        if (!isPredOrFunc(pred)) {
          throw new TypeError(
            name + ": Second argument must be a Pred or predicate Function"
          );
        }
        if (isNil(x)) {
          return false;
        }
        var target = x;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
            throw new TypeError(err(name));
          }
          if (isNil(target)) {
            return false;
          }
          target = target[key];
        }
        return !!predOrFunc(pred, target);
      }
      return curry(pathSatisfies2);
    }
    var pathSatisfies = fn("pathSatisfies");
    pathSatisfies.origFn = fn;
    module.exports = pathSatisfies;
  }
});

// node_modules/crocks/predicates/propEq.js
var require_propEq = __commonJS({
  "node_modules/crocks/predicates/propEq.js"(exports, module) {
    var curry = require_curry();
    var equals = require_equals();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    function propEq(key, value, x) {
      if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
        throw new TypeError(
          "propEq: Non-empty String or Integer required for first argument"
        );
      }
      if (isNil(x)) {
        return false;
      }
      var target = x[key];
      return isDefined(target) && equals(target, value);
    }
    module.exports = curry(propEq);
  }
});

// node_modules/crocks/predicates/propPathEq.js
var require_propPathEq = __commonJS({
  "node_modules/crocks/predicates/propPathEq.js"(exports, module) {
    var pathEq = require_pathEq();
    module.exports = pathEq.origFn("propPathEq");
  }
});

// node_modules/crocks/predicates/propSatisfies.js
var require_propSatisfies = __commonJS({
  "node_modules/crocks/predicates/propSatisfies.js"(exports, module) {
    var curry = require_curry();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isPredOrFunc = require_isPredOrFunc();
    var isString = require_isString();
    var predOrFunc = require_predOrFunc();
    function propSatisfies(key, pred, x) {
      if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
        throw new TypeError(
          "propSatisfies: Non-empty String or Integer required for first argument"
        );
      }
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "propSatisfies: Pred or predicate function required for second argument"
        );
      }
      return isNil(x) ? false : !!predOrFunc(pred, x[key]);
    }
    module.exports = curry(propSatisfies);
  }
});

// node_modules/crocks/predicates/propPathSatisfies.js
var require_propPathSatisfies = __commonJS({
  "node_modules/crocks/predicates/propPathSatisfies.js"(exports, module) {
    var pathSatisfies = require_pathSatisfies();
    module.exports = pathSatisfies.origFn("propPathSatisfies");
  }
});

// node_modules/crocks/predicates/index.js
var require_predicates = __commonJS({
  "node_modules/crocks/predicates/index.js"(exports, module) {
    module.exports = {
      hasProp: require_hasProp(),
      hasProps: require_hasProps(),
      hasPropPath: require_hasPropPath(),
      isAlt: require_isAlt2(),
      isAlternative: require_isAlternative(),
      isApplicative: require_isApplicative2(),
      isApply: require_isApply2(),
      isArray: require_isArray2(),
      isBifunctor: require_isBifunctor2(),
      isBichain: require_isBichain2(),
      isBoolean: require_isBoolean(),
      isCategory: require_isCategory(),
      isChain: require_isChain2(),
      isContravariant: require_isContravariant2(),
      isDate: require_isDate2(),
      isDefined: require_isDefined2(),
      isEmpty: require_isEmpty2(),
      isExtend: require_isExtend2(),
      isFalse: require_isFalse(),
      isFalsy: require_isFalsy(),
      isFoldable: require_isFoldable2(),
      isFunction: require_isFunction2(),
      isFunctor: require_isFunctor2(),
      isInteger: require_isInteger2(),
      isIterable: require_isIterable2(),
      isMap: require_isMap2(),
      isMonad: require_isMonad2(),
      isMonoid: require_isMonoid2(),
      isNil: require_isNil2(),
      isNumber: require_isNumber2(),
      isObject: require_isObject2(),
      isPlus: require_isPlus2(),
      isProfunctor: require_isProfunctor2(),
      isPromise: require_isPromise2(),
      isSame: require_isSame2(),
      isSameType: require_isSameType2(),
      isSemigroup: require_isSemigroup2(),
      isSemigroupoid: require_isSemigroupoid2(),
      isSetoid: require_isSetoid(),
      isString: require_isString2(),
      isSymbol: require_isSymbol2(),
      isTraversable: require_isTraversable(),
      isTrue: require_isTrue(),
      isTruthy: require_isTruthy(),
      pathEq: require_pathEq(),
      pathSatisfies: require_pathSatisfies(),
      propEq: require_propEq(),
      propPathEq: require_propPathEq(),
      propSatisfies: require_propSatisfies(),
      propPathSatisfies: require_propPathSatisfies()
    };
  }
});

// node_modules/crocks/core/implements.js
var require_implements = __commonJS({
  "node_modules/crocks/core/implements.js"(exports, module) {
    var fulfills = function(algs) {
      return function(test) {
        return algs.indexOf(test) !== -1;
      };
    };
    module.exports = fulfills;
  }
});

// node_modules/crocks/core/inspect.js
var require_inspect = __commonJS({
  "node_modules/crocks/core/inspect.js"(exports, module) {
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isString = require_isString();
    var isSymbol = require_isSymbol();
    var isDate = require_isDate();
    function arrayInspect(xs) {
      return xs.length ? xs.map(inspect).reduce(function(a, x) {
        return a + "," + x;
      }) : xs;
    }
    function inspect(x) {
      if (x && isFunction(x.inspect)) {
        return " " + x.inspect();
      }
      if (isFunction(x)) {
        return " Function";
      }
      if (isArray(x)) {
        return " [" + arrayInspect(x) + " ]";
      }
      if (isObject(x)) {
        return " { " + Object.keys(x).reduce(function(acc, key) {
          return acc.concat([key + ":" + inspect(x[key])]);
        }, []).join(", ") + " }";
      }
      if (isString(x)) {
        return ' "' + x + '"';
      }
      if (isSymbol(x) || isDate(x)) {
        return " " + x.toString();
      }
      return " " + x;
    }
    module.exports = inspect;
  }
});

// node_modules/crocks/Arrow/index.js
var require_Arrow = __commonJS({
  "node_modules/crocks/Arrow/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Arrow");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var Pair = require_types().proxy("Pair");
    var _id = function() {
      return Arrow(function(x) {
        return x;
      });
    };
    function Arrow(runWith) {
      var obj;
      if (!isFunction(runWith)) {
        throw new TypeError("Arrow: Function required");
      }
      var inspect = function() {
        return "Arrow" + _inspect(runWith);
      };
      var id = _id;
      var _map = function(fn) {
        return Arrow(function(x) {
          return fn(runWith(x));
        });
      };
      function compose(method) {
        return function(m) {
          if (!isSameType(Arrow, m)) {
            throw new TypeError("Arrow." + method + ": Arrow required");
          }
          return _map(m.runWith);
        };
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Arrow." + method + ": Function required");
          }
          return _map(fn);
        };
      }
      function contramap(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Arrow." + method + ": Function required");
          }
          return Arrow(function(x) {
            return runWith(fn(x));
          });
        };
      }
      function promap(method) {
        return function(l, r) {
          if (!isFunction(l) || !isFunction(r)) {
            throw new TypeError("Arrow." + method + ": Functions required for both arguments");
          }
          return Arrow(function(x) {
            return r(runWith(l(x)));
          });
        };
      }
      function first() {
        return Arrow(function(x) {
          if (!isSameType(Pair, x)) {
            throw TypeError("Arrow.first: Pair required for inner argument");
          }
          return x.bimap(runWith, function(x2) {
            return x2;
          });
        });
      }
      function second() {
        return Arrow(function(x) {
          if (!isSameType(Pair, x)) {
            throw TypeError("Arrow.second: Pair required for inner argument");
          }
          return x.bimap(function(x2) {
            return x2;
          }, runWith);
        });
      }
      function both() {
        return Arrow(function(x) {
          if (!isSameType(Pair, x)) {
            throw TypeError("Arrow.both: Pair required for inner argument");
          }
          return x.bimap(runWith, runWith);
        });
      }
      return obj = {
        inspect,
        toString: inspect,
        type,
        runWith,
        id,
        first,
        second,
        both,
        compose: compose("compose"),
        map: map("map"),
        contramap: contramap("contramap"),
        promap: promap("promap")
      }, obj[fl.id] = id, obj[fl.compose] = compose(fl.compose), obj[fl.map] = map(fl.map), obj[fl.contramap] = contramap(fl.contramap), obj[fl.promap] = promap(fl.promap), obj["@@type"] = _type, obj.constructor = Arrow, obj;
    }
    Arrow.id = _id;
    Arrow.type = type;
    Arrow[fl.id] = _id;
    Arrow["@@type"] = _type;
    Arrow["@@implements"] = _implements(
      ["compose", "contramap", "id", "map", "promap"]
    );
    module.exports = Arrow;
  }
});

// node_modules/crocks/core/isTypeRepOf.js
var require_isTypeRepOf = __commonJS({
  "node_modules/crocks/core/isTypeRepOf.js"(exports, module) {
    var isFunction = require_isFunction();
    var isTypeRepOf = function(x, y) {
      return isFunction(y) && (x === y || x.name === y.name);
    };
    module.exports = isTypeRepOf;
  }
});

// node_modules/crocks/core/apOrFunc.js
var require_apOrFunc = __commonJS({
  "node_modules/crocks/core/apOrFunc.js"(exports, module) {
    var isApplicative = require_isApplicative();
    var isTypeRepOf = require_isTypeRepOf();
    var apOrFunc = function(af) {
      return function(x) {
        return isApplicative(af) ? af.of(x) : isTypeRepOf(Array, af) ? [x] : af(x);
      };
    };
    module.exports = apOrFunc;
  }
});

// node_modules/crocks/core/array.js
var require_array = __commonJS({
  "node_modules/crocks/core/array.js"(exports, module) {
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var apOrFunc = require_apOrFunc();
    var identity = function(x) {
      return x;
    };
    var concat = function(x) {
      return function(m) {
        return x.concat(m);
      };
    };
    function runTraverse(name, fn) {
      return function(acc, x) {
        var m = fn(x);
        if (!((isApply(acc) || isArray(acc)) && isSameType(acc, m))) {
          throw new TypeError("Array." + name + ": Must wrap Applys of the same type");
        }
        if (isArray(m)) {
          return ap(acc, map(function(v) {
            return concat([v]);
          }, m));
        }
        return m.map(function(v) {
          return concat([v]);
        }).ap(acc);
      };
    }
    var allFuncs = function(xs) {
      return xs.reduce(function(b, i) {
        return b && isFunction(i);
      }, true);
    };
    var map = function(f, m) {
      return m.map(function(x) {
        return f(x);
      });
    };
    function ap(x, m) {
      if (!(m.length && allFuncs(m))) {
        throw new TypeError("Array.ap: Second Array must all be functions");
      }
      return m.reduce(function(acc, f) {
        return acc.concat(map(f, x));
      }, []);
    }
    function chain(f, m) {
      return m.reduce(function(y, x) {
        var n = f(x);
        if (!isArray(n)) {
          throw new TypeError("Array.chain: Function must return an Array");
        }
        return y.concat(n);
      }, []);
    }
    function sequence(f, m) {
      var fn = apOrFunc(f);
      return m.reduceRight(runTraverse("sequence", identity), fn([]));
    }
    function traverse(f, fn, m) {
      var af = apOrFunc(f);
      return m.reduceRight(runTraverse("traverse", fn), af([]));
    }
    function fold(m) {
      if (isEmpty(m)) {
        throw new TypeError(
          "Array.fold: Non-empty Array of Semigroups required"
        );
      }
      var head = m[0];
      if (!isSemigroup(head)) {
        throw new TypeError("Array.fold: Must contain Semigroups of the same type");
      }
      return m.reduce(function(x, y) {
        if (!isSameType(x, y)) {
          throw new TypeError("Array.fold: Must contain Semigroups of the same type");
        }
        return x.concat(y);
      });
    }
    function foldMap(fn, m) {
      if (isEmpty(m)) {
        throw new TypeError(
          "Array.foldMap: Non-empty Array required"
        );
      }
      var head = fn(m[0]);
      if (!isSemigroup(head)) {
        throw new TypeError(
          "Array.foldMap: Provided function must return Semigroups of the same type"
        );
      }
      return m.length === 1 ? head : m.slice(1).reduce(function(semi, x) {
        var val = fn(x);
        if (!(isSameType(semi, val) && isSemigroup(val))) {
          throw new TypeError(
            "Array.foldMap: Provided function must return Semigroups of the same type"
          );
        }
        return semi.concat(val);
      }, head);
    }
    function set(indx, val, m) {
      var arr = m.slice();
      arr[indx] = val;
      return arr;
    }
    function unset(indx, m) {
      return m.slice(0, indx).concat(m.slice(indx + 1));
    }
    module.exports = {
      ap,
      chain,
      fold,
      foldMap,
      map,
      sequence,
      set,
      traverse,
      unset
    };
  }
});

// node_modules/crocks/core/once.js
var require_once = __commonJS({
  "node_modules/crocks/core/once.js"(exports, module) {
    function once(fn) {
      var called, result;
      return function() {
        if (!called) {
          called = true;
          result = fn.apply(null, arguments);
        }
        return result;
      };
    }
    module.exports = once;
  }
});

// node_modules/crocks/core/_unit.js
var require_unit = __commonJS({
  "node_modules/crocks/core/_unit.js"(exports, module) {
    module.exports = Function.prototype;
  }
});

// node_modules/crocks/Async/index.js
var require_Async = __commonJS({
  "node_modules/crocks/Async/index.js"(exports, module) {
    var VERSION = 5;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Async");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var array = require_array();
    var compose = require_compose();
    var once = require_once();
    var unit = require_unit();
    var isArray = require_isArray();
    var isFoldable = require_isFoldable();
    var isFunction = require_isFunction();
    var isInteger = require_isInteger();
    var isPromise = require_isPromise();
    var isSameType = require_isSameType();
    var allAsyncs = function(xs) {
      return xs.reduce(function(acc, x) {
        return acc && isSameType(Async, x);
      }, true);
    };
    var _of = function(x) {
      return Async(function(_, resolve) {
        return resolve(x);
      });
    };
    var Rejected = function(x) {
      return Async(function(reject) {
        return reject(x);
      });
    };
    function all(asyncs) {
      if (!(isFoldable(asyncs) && allAsyncs(asyncs))) {
        throw new TypeError("Async.all: Foldable structure of Asyncs required");
      }
      if (isArray(asyncs)) {
        return array.sequence(Async.of, asyncs);
      }
      return asyncs.sequence(Async.of);
    }
    function fromNode(fn, ctx) {
      if (!isFunction(fn)) {
        throw new TypeError("Async.fromNode: CPS function required");
      }
      return function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        return Async(function(reject, resolve) {
          fn.apply(
            ctx,
            args.concat(
              function(err, data) {
                return err ? reject(err) : resolve(data);
              }
            )
          );
        });
      };
    }
    function fromPromise(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("Async.fromPromise: Promise returning function required");
      }
      return function() {
        var promiseArgs = arguments;
        return Async(function(reject, resolve) {
          var promise = fn.apply(null, promiseArgs);
          if (!isPromise(promise)) {
            throw new TypeError("Async.fromPromise: Promise returning function required");
          }
          promise.then(resolve, reject);
        });
      };
    }
    function rejectAfter(ms, value) {
      if (!(isInteger(ms) && ms >= 0)) {
        throw new TypeError(
          "Async.rejectAfter: Positive Integer required for first argument"
        );
      }
      return Async(function(rej) {
        var token = setTimeout(function() {
          rej(value);
        }, ms);
        return function() {
          clearTimeout(token);
        };
      });
    }
    function resolveAfter(ms, value) {
      if (!(isInteger(ms) && ms >= 0)) {
        throw new TypeError(
          "Async.resolveAfter: Positive Integer required for first argument"
        );
      }
      return Async(function(_, res) {
        var token = setTimeout(function() {
          res(value);
        }, ms);
        return function() {
          clearTimeout(token);
        };
      });
    }
    function Async(fn) {
      var obj;
      if (!isFunction(fn)) {
        throw new TypeError("Async: Function required");
      }
      var of = _of;
      var inspect = function() {
        return "Async" + _inspect(fn);
      };
      function fork(reject, resolve, cleanup) {
        if (!isFunction(reject) || !isFunction(resolve)) {
          throw new TypeError("Async.fork: Reject and resolve functions required");
        }
        var cancelled = false;
        var settled = false;
        var cancel = function() {
          cancelled = true;
        };
        var forkCancel = isFunction(cleanup) ? cleanup : unit;
        var settle = function(f, x) {
          if (!settled) {
            settled = true;
            if (cancelled) {
              return unit();
            }
            return f(x);
          }
        };
        var internal = fn(
          settle.bind(null, reject),
          settle.bind(null, resolve)
        );
        var internalFn = isFunction(internal) ? internal : unit;
        return once(function() {
          return forkCancel(cancel(internalFn()));
        });
      }
      function toPromise() {
        return new Promise(function(resolve, reject) {
          fork(reject, resolve);
        });
      }
      function race(m) {
        if (!isSameType(Async, m)) {
          throw new TypeError("Async.race: Async required");
        }
        return Async(function(reject, resolve) {
          var settle = once(
            function(resolved, value) {
              return resolved ? resolve(value) : reject(value);
            }
          );
          var res = settle.bind(null, true);
          var rej = settle.bind(null, false);
          var cancelOne = fork(rej, res);
          var cancelTwo = m.fork(rej, res);
          return function() {
            cancelOne();
            cancelTwo();
          };
        });
      }
      function swap(l, r) {
        if (!isFunction(l) || !isFunction(r)) {
          throw new TypeError("Async.swap: Functions required for both arguments");
        }
        return Async(function(reject, resolve) {
          return fork(
            compose(resolve, l),
            compose(reject, r)
          );
        });
      }
      function coalesce(l, r) {
        if (!isFunction(l) || !isFunction(r)) {
          throw new TypeError("Async.coalesce: Functions required for both arguments");
        }
        return Async(function(reject, resolve) {
          return fork(
            compose(resolve, l),
            compose(resolve, r)
          );
        });
      }
      function map(method) {
        return function(mapFn) {
          if (!isFunction(mapFn)) {
            throw new TypeError("Async." + method + ": Function required");
          }
          return Async(function(reject, resolve) {
            return fork(reject, compose(resolve, mapFn));
          });
        };
      }
      function bimap(method) {
        return function(l, r) {
          if (!isFunction(l) || !isFunction(r)) {
            throw new TypeError("Async." + method + ": Functions required for both arguments");
          }
          return Async(function(reject, resolve) {
            return fork(
              compose(reject, l),
              compose(resolve, r)
            );
          });
        };
      }
      function alt(method) {
        return function(m) {
          if (!isSameType(Async, m)) {
            throw new TypeError("Async." + method + ": Async required");
          }
          return Async(function(rej, res) {
            var cancel = unit;
            var innerCancel = unit;
            cancel = fork(
              function() {
                innerCancel = m.fork(rej, res);
              },
              res
            );
            return once(function() {
              return innerCancel(cancel());
            });
          });
        };
      }
      function ap(m) {
        if (!isSameType(Async, m)) {
          throw new TypeError("Async.ap: Async required");
        }
        return Async(function(reject, resolve) {
          var apFn = null;
          var value = null;
          var fnDone = false;
          var valueDone = false;
          var cancelled = false;
          var cancel = function() {
            cancelled = true;
          };
          var rejectOnce = once(reject);
          function resolveBoth() {
            if (!cancelled && fnDone && valueDone) {
              compose(resolve, apFn)(value);
            }
          }
          var fnCancel = fork(rejectOnce, function(f) {
            if (!isFunction(f)) {
              throw new TypeError("Async.ap: Wrapped value must be a function");
            }
            fnDone = true;
            apFn = f;
            resolveBoth();
          });
          var valueCancel = m.fork(rejectOnce, function(x) {
            valueDone = true;
            value = x;
            resolveBoth();
          });
          return function() {
            fnCancel();
            valueCancel();
            cancel();
          };
        });
      }
      function chain(method) {
        return function(mapFn) {
          if (!isFunction(mapFn)) {
            throw new TypeError(
              "Async." + method + ": Async returning function required"
            );
          }
          return Async(function(reject, resolve) {
            var cancel = unit;
            var innerCancel = unit;
            cancel = fork(reject, function(x) {
              var m = mapFn(x);
              if (!isSameType(Async, m)) {
                throw new TypeError(
                  "Async." + method + ": Function must return another Async"
                );
              }
              innerCancel = m.fork(reject, resolve);
            });
            return once(function() {
              return innerCancel(cancel());
            });
          });
        };
      }
      function bichain(l, r) {
        var bichainErr = "Async.bichain: Both arguments must be Async returning functions";
        if (!isFunction(l) || !isFunction(r)) {
          throw new TypeError(bichainErr);
        }
        return Async(function(rej, res) {
          var cancel = unit;
          var innerCancel = unit;
          function setInnerCancel(mapFn) {
            return function(x) {
              var m = mapFn(x);
              if (!isSameType(Async, m)) {
                throw new TypeError(bichainErr);
              }
              innerCancel = m.fork(rej, res);
            };
          }
          cancel = fork(setInnerCancel(l), setInnerCancel(r));
          return once(function() {
            return innerCancel(cancel());
          });
        });
      }
      return obj = {
        fork,
        toPromise,
        inspect,
        toString: inspect,
        type,
        swap,
        race,
        coalesce,
        ap,
        of,
        alt: alt("alt"),
        bimap: bimap("bimap"),
        map: map("map"),
        chain: chain("chain"),
        bichain
      }, obj[fl.of] = of, obj[fl.alt] = alt(fl.alt), obj[fl.bimap] = bimap(fl.bimap), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Async, obj;
    }
    Async.of = _of;
    Async.type = type;
    Async[fl.of] = _of;
    Async["@@type"] = _type;
    Async.Rejected = Rejected;
    Async.Resolved = _of;
    Async.fromPromise = fromPromise;
    Async.fromNode = fromNode;
    Async.all = all;
    Async.rejectAfter = rejectAfter;
    Async.resolveAfter = resolveAfter;
    Async["@@implements"] = _implements(
      ["alt", "ap", "bimap", "chain", "map", "of"]
    );
    module.exports = Async;
  }
});

// node_modules/crocks/Const/index.js
var require_Const = __commonJS({
  "node_modules/crocks/Const/index.js"(exports, module) {
    var VERSION = 3;
    var _equals = require_equals();
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _type = require_types().type("Const");
    var typeFn = require_types().typeFn;
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isMonoid = require_isMonoid();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var typeOrName = function(m) {
      return isFunction(m.type) ? m.type() : m.name;
    };
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var empties = {
      Array: function() {
        return [];
      },
      String: function() {
        return "";
      }
    };
    var getEmpty = function(T) {
      return T[fl.empty] || T.empty || empties[T.name];
    };
    var validMonoid = function(T) {
      return isMonoid(T) || T.name === "String" || T.name === "Array";
    };
    function _Const(T) {
      if (!isFunction(T)) {
        throw new TypeError("Const: TypeRep required for construction");
      }
      var type = constant(_type(typeOrName(T)));
      var typeString = typeFn("Const", VERSION, typeOrName(T));
      function empty(method) {
        return function() {
          if (!validMonoid(T)) {
            throw new TypeError(type() + "." + method + ": Must be fixed to a Monoid");
          }
          return Const(getEmpty(T)());
        };
      }
      function of(method) {
        return function() {
          if (!validMonoid(T)) {
            throw new TypeError(type() + "." + method + ": Must be fixed to a Monoid");
          }
          return Const(getEmpty(T)());
        };
      }
      function Const(value) {
        var obj;
        if (!isSameType(T, value)) {
          throw new TypeError(type() + ": " + typeOrName(T) + " required");
        }
        var inspect = constant("" + type() + _inspect(value));
        var valueOf = constant(value);
        var equals = function(m) {
          return isSameType(Const, m) && _equals(value, m.valueOf());
        };
        function concat(method) {
          return function(m) {
            if (!isSemigroup(value)) {
              throw new TypeError(type() + "." + method + ": Must be fixed to a Semigroup");
            }
            if (!isSameType(Const, m)) {
              throw new TypeError(type() + "." + method + ": " + type() + " required");
            }
            return Const(value.concat(m.valueOf()));
          };
        }
        function map(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError(type() + "." + method + ": Function required");
            }
            return Const(value);
          };
        }
        function ap(m) {
          if (!isSemigroup(value)) {
            throw new TypeError(type() + ".ap: Must be fixed to a Semigroup");
          }
          if (!isSameType(Const, m)) {
            throw new TypeError(type() + ".ap: " + type() + " required");
          }
          return Const(value.concat(m.valueOf()));
        }
        return obj = {
          inspect,
          toString: inspect,
          valueOf,
          type,
          ap,
          equals,
          concat: concat("concat"),
          empty: empty("empty"),
          map: map("map"),
          of: of("of")
        }, obj[fl.concat] = concat(fl.concat), obj[fl.empty] = empty(fl.empty), obj[fl.equals] = equals, obj[fl.map] = map(fl.map), obj[fl.of] = of(fl.of), obj["@@type"] = typeString, obj.constructor = Const, obj;
      }
      Const.empty = empty("empty");
      Const.of = of("of");
      Const.type = type;
      Const[fl.empty] = empty(fl.empty);
      Const[fl.of] = of(fl.of);
      Const["@@type"] = typeString;
      Const["@@implements"] = _implements(
        ["ap", "concat", "empty", "equals", "map", "of"]
      );
      return Const;
    }
    module.exports = _Const;
  }
});

// node_modules/crocks/core/defineUnion.js
var require_defineUnion = __commonJS({
  "node_modules/crocks/core/defineUnion.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isString = require_isString();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var isDefinition = function(x) {
      return isString(x) && x.length;
    };
    function caseOf(defs) {
      return function(cases, m) {
        var tag = m.tag;
        var def = defs[tag()];
        var args = def.reduce(
          function(xs, x) {
            return xs.concat([m[x].value()]);
          },
          []
        );
        return cases[tag()].apply(null, args);
      };
    }
    var includes = function(defs) {
      return function(m) {
        return !!m && isFunction(m.tag) && Object.keys(defs).indexOf(m.tag()) !== -1;
      };
    };
    function construction(def, tag) {
      return function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        return def.reduce(function(obj, key, index) {
          obj[key] = { value: constant(args[index]) };
          return obj;
        }, { tag: constant(tag) });
      };
    }
    function defineUnion(defs) {
      if (!isObject(defs) || isEmpty(defs)) {
        throw new TypeError("defineUnion: Argument must be an Object containing definition lists");
      }
      return Object.keys(defs).reduce(function(obj, tag) {
        var def = defs[tag];
        if (!isArray(def) || !def.reduce(function(x, y) {
          return x && isDefinition(y);
        }, true)) {
          throw new TypeError("defineUnion: Definitions must be a list of non-empty string identifiers");
        }
        obj[tag] = construction(def, tag);
        return obj;
      }, { caseOf: curry(caseOf(defs)), includes: curry(includes(defs)) });
    }
    module.exports = defineUnion;
  }
});

// node_modules/crocks/core/innerConcat.js
var require_innerConcat = __commonJS({
  "node_modules/crocks/core/innerConcat.js"(exports, module) {
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    function innerConcat(method, m) {
      return function(left) {
        if (!isSemigroup(left)) {
          throw new TypeError(method + ": Both containers must contain Semigroups of the same type");
        }
        return m.map(function(right) {
          if (!isSameType(left, right)) {
            throw new TypeError(method + ": Both containers must contain Semigroups of the same type");
          }
          return left.concat(right);
        });
      };
    }
    module.exports = innerConcat;
  }
});

// node_modules/crocks/Either/index.js
var require_Either = __commonJS({
  "node_modules/crocks/Either/index.js"(exports, module) {
    var VERSION = 4;
    var _defineUnion = require_defineUnion();
    var _equals = require_equals();
    var _implements = require_implements();
    var _innerConcat = require_innerConcat();
    var _inspect = require_inspect();
    var type = require_types().type("Either");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var apOrFunc = require_apOrFunc();
    var compose = require_compose();
    var isArray = require_isArray();
    var isApplicative = require_isApplicative();
    var isApply = require_isApply();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var _either = _defineUnion({ Left: ["a"], Right: ["b"] });
    var Left = _either.Left;
    var Right = _either.Right;
    Either.Left = compose(Either, Left);
    Either.Right = compose(Either, Right);
    var _of = Either.Right;
    function runSequence(x) {
      if (!(isApply(x) || isArray(x))) {
        throw new TypeError("Either.sequence: Must wrap an Apply");
      }
      return x.map(_of);
    }
    function Either(u) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("Either: Must wrap something, try using Left or Right constructors");
      }
      var x = !_either.includes(u) ? Right(u) : u;
      var equals = function(m) {
        return isSameType(Either, m) && either(
          function(x2) {
            return m.either(function(y) {
              return _equals(y, x2);
            }, constant(false));
          },
          function(x2) {
            return m.either(constant(false), function(y) {
              return _equals(y, x2);
            });
          }
        );
      };
      var of = _of;
      var inspect = function() {
        return either(
          function(l) {
            return "Left" + _inspect(l);
          },
          function(r) {
            return "Right" + _inspect(r);
          }
        );
      };
      function either(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Either.either: Requires both left and right functions");
        }
        return _either.caseOf({
          Left: f,
          Right: g
        }, x);
      }
      function concat(method) {
        return function(m) {
          if (!isSameType(Either, m)) {
            throw new TypeError("Either." + method + ": Either of Semigroup required");
          }
          return either(
            Either.Left,
            _innerConcat("Either." + method, m)
          );
        };
      }
      function swap(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Either.swap: Requires both left and right functions");
        }
        return either(
          compose(Either.Right, f),
          compose(Either.Left, g)
        );
      }
      function coalesce(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Either.coalesce: Requires both left and right functions");
        }
        return Either.Right(either(f, g));
      }
      function bichain(l, r) {
        var bichainErr = "Either.bichain: Both arguments must be Either returning functions";
        if (!(isFunction(l) && isFunction(r))) {
          throw new TypeError(bichainErr);
        }
        var m = either(l, r);
        if (!isSameType(Either, m)) {
          throw new TypeError(bichainErr);
        }
        return m;
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Either." + method + ": Function required");
          }
          return either(Either.Left, compose(Either.Right, fn));
        };
      }
      function bimap(method) {
        return function(f, g) {
          if (!isFunction(f) || !isFunction(g)) {
            throw new TypeError("Either." + method + ": Requires both left and right functions");
          }
          return either(
            compose(Either.Left, f),
            compose(Either.Right, g)
          );
        };
      }
      function alt(method) {
        return function(m) {
          if (!isSameType(Either, m)) {
            throw new TypeError("Either." + method + ": Either required");
          }
          return either(
            constant(m),
            Either.Right
          );
        };
      }
      function ap(m) {
        if (!either(constant(true), isFunction)) {
          throw new TypeError("Either.ap: Wrapped value must be a function");
        } else if (!either(constant(true), constant(isSameType(Either, m)))) {
          throw new TypeError("Either.ap: Either required");
        }
        return either(
          Either.Left,
          function(fn) {
            return m.map(fn);
          }
        );
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Either." + method + ": Function required");
          }
          var m = either(Either.Left, fn);
          if (!isSameType(Either, m)) {
            throw new TypeError("Either." + method + ": Function must return an Either");
          }
          return m;
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Either.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        var af = apOrFunc(f);
        return either(
          compose(af, Either.Left),
          runSequence
        );
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Either.traverse: Applicative TypeRep or Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "Either.traverse: Apply returning function required for second argument"
          );
        }
        var af = apOrFunc(f);
        var m = either(compose(af, Either.Left), fn);
        if (!(isApply(m) || isArray(m))) {
          throw new TypeError(
            "Either.traverse: Both functions must return an Apply of the same type"
          );
        }
        return either(
          constant(m),
          constant(m.map(_of))
        );
      }
      return obj = {
        inspect,
        toString: inspect,
        either,
        type,
        swap,
        coalesce,
        bichain,
        equals,
        ap,
        of,
        sequence,
        traverse,
        alt: alt("alt"),
        bimap: bimap("bimap"),
        concat: concat("concat"),
        chain: chain("chain"),
        map: map("map")
      }, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.alt] = alt(fl.alt), obj[fl.bimap] = bimap(fl.bimap), obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Either, obj;
    }
    Either.of = _of;
    Either.type = type;
    Either[fl.of] = _of;
    Either["@@type"] = _type;
    Either["@@implements"] = _implements(
      ["alt", "ap", "bimap", "chain", "concat", "equals", "map", "of", "traverse"]
    );
    module.exports = Either;
  }
});

// node_modules/crocks/Equiv/index.js
var require_Equiv = __commonJS({
  "node_modules/crocks/Equiv/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var type = require_types().type("Equiv");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var _empty = function() {
      return Equiv(function() {
        return true;
      });
    };
    function Equiv(compare) {
      var obj;
      if (!isFunction(compare)) {
        throw new TypeError("Equiv: Comparison function required");
      }
      var compareWith = curry(
        function(x, y) {
          return !!compare(x, y);
        }
      );
      var inspect = function() {
        return "Equiv" + _inspect(compare);
      };
      var empty = _empty;
      var valueOf = function() {
        return compareWith;
      };
      function contramap(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Equiv." + method + ": Function required");
          }
          return Equiv(
            function(x, y) {
              return compareWith(fn(x), fn(y));
            }
          );
        };
      }
      function concat(method) {
        return function(m) {
          if (!isSameType(Equiv, m)) {
            throw new TypeError("Equiv." + method + ": Equiv required");
          }
          return Equiv(
            function(x, y) {
              return compareWith(x, y) && m.compareWith(x, y);
            }
          );
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        type,
        compareWith,
        valueOf,
        empty,
        concat: concat("concat"),
        contramap: contramap("contramap")
      }, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj[fl.contramap] = contramap(fl.contramap), obj["@@type"] = _type, obj.constructor = Equiv, obj;
    }
    Equiv.empty = _empty;
    Equiv.type = type;
    Equiv[fl.empty] = _empty;
    Equiv["@@type"] = _type;
    Equiv["@@implements"] = _implements(
      ["concat", "contramap", "empty"]
    );
    module.exports = Equiv;
  }
});

// node_modules/crocks/Identity/index.js
var require_Identity = __commonJS({
  "node_modules/crocks/Identity/index.js"(exports, module) {
    var VERSION = 3;
    var _equals = require_equals();
    var _implements = require_implements();
    var _innerConcat = require_innerConcat();
    var _inspect = require_inspect();
    var type = require_types().type("Identity");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isArray = require_isArray();
    var isApply = require_isApply();
    var isApplicative = require_isApplicative();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _of = Identity;
    function Identity(x) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("Identity: Must wrap something");
      }
      var valueOf = function() {
        return x;
      };
      var of = _of;
      var equals = function(m) {
        return isSameType(Identity, m) && _equals(x, m.valueOf());
      };
      var inspect = function() {
        return "Identity" + _inspect(x);
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Identity, m)) {
            throw new TypeError("Identity." + method + ": Identity of Semigroup required");
          }
          return _innerConcat("Identity." + method, m)(x);
        };
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Identity." + method + ": Function required");
          }
          return Identity(fn(x));
        };
      }
      function ap(m) {
        if (!isFunction(x)) {
          throw new TypeError("Identity.ap: Wrapped value must be a function");
        } else if (!isSameType(Identity, m)) {
          throw new TypeError("Identity.ap: Identity required");
        }
        return m.map(x);
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Identity." + method + ": Function required");
          }
          var m = fn(x);
          if (!isSameType(Identity, m)) {
            throw new TypeError("Identity." + method + ": Function must return an Identity");
          }
          return m;
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Identity.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        if (!(isApply(x) || isArray(x))) {
          throw new TypeError("Identity.sequence: Must wrap an Apply");
        }
        return x.map(_of);
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Identity.traverse: Applicative TypeRep or Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "Identity.traverse: Apply returning functions required for second argument"
          );
        }
        var m = fn(x);
        if (!(isApply(m) || isArray(m))) {
          throw new TypeError(
            "Identity.traverse: Both functions must return an Apply of the same type"
          );
        }
        return m.map(_of);
      }
      return obj = {
        inspect,
        toString: inspect,
        valueOf,
        type,
        equals,
        ap,
        of,
        sequence,
        traverse,
        concat: concat("concat"),
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Identity, obj;
    }
    Identity.of = _of;
    Identity.type = type;
    Identity[fl.of] = _of;
    Identity["@@type"] = _type;
    Identity["@@implements"] = _implements(
      ["ap", "chain", "concat", "equals", "map", "of", "traverse"]
    );
    module.exports = Identity;
  }
});

// node_modules/crocks/IO/index.js
var require_IO = __commonJS({
  "node_modules/crocks/IO/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("IO");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var compose = require_compose();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _of = function(x) {
      return IO(function() {
        return x;
      });
    };
    function IO(run) {
      var obj;
      if (!isFunction(run)) {
        throw new TypeError("IO: Must wrap a function");
      }
      var of = _of;
      var inspect = function() {
        return "IO" + _inspect(run);
      };
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("IO." + method + ": Function required");
          }
          return IO(compose(fn, run));
        };
      }
      function ap(m) {
        if (!isSameType(IO, m)) {
          throw new TypeError("IO.ap: IO required");
        }
        return IO(function() {
          var fn = run();
          if (!isFunction(fn)) {
            throw new TypeError("IO.ap: Wrapped value must be a function");
          }
          return m.map(fn).run();
        });
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("IO." + method + ": Function required");
          }
          return IO(function() {
            var m = fn(run());
            if (!isSameType(IO, m)) {
              throw new TypeError("IO." + method + ": Function must return an IO");
            }
            return m.run();
          });
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        run,
        type,
        ap,
        of,
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = IO, obj;
    }
    IO.of = _of;
    IO.type = type;
    IO[fl.of] = _of;
    IO["@@type"] = _type;
    IO["@@implements"] = _implements(
      ["ap", "chain", "map", "of"]
    );
    module.exports = IO;
  }
});

// node_modules/crocks/core/Maybe.js
var require_Maybe = __commonJS({
  "node_modules/crocks/core/Maybe.js"(exports, module) {
    var VERSION = 4;
    var _defineUnion = require_defineUnion();
    var _equals = require_equals();
    var _implements = require_implements();
    var _innerConcat = require_innerConcat();
    var _inspect = require_inspect();
    var type = require_types().type("Maybe");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var apOrFunc = require_apOrFunc();
    var compose = require_compose();
    var isApplicative = require_isApplicative();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var identity = function(x) {
      return x;
    };
    var _maybe = _defineUnion({ Nothing: [], Just: ["a"] });
    var Nothing = _maybe.Nothing;
    var Just = _maybe.Just;
    Maybe.Nothing = compose(Maybe, Nothing);
    Maybe.Just = compose(Maybe, Just);
    var _of = compose(Maybe, Just);
    var _zero = compose(Maybe, Nothing);
    function runSequence(x) {
      if (!(isApply(x) || isArray(x))) {
        throw new TypeError(
          "Maybe.sequence: Must wrap an Apply"
        );
      }
      return x.map(_of);
    }
    function Maybe(u) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("Maybe: Must wrap something, try using Nothing or Just constructors");
      }
      var x = !_maybe.includes(u) ? Just(u) : u;
      var of = _of;
      var zero = _zero;
      var option = function(n) {
        return either(constant(n), identity);
      };
      var equals = function(m) {
        return isSameType(Maybe, m) && either(
          constant(m.either(constant(true), constant(false))),
          function(x2) {
            return m.either(constant(false), function(y) {
              return _equals(y, x2);
            });
          }
        );
      };
      var inspect = function() {
        return either(
          constant("Nothing"),
          function(x2) {
            return "Just" + _inspect(x2);
          }
        );
      };
      function either(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Maybe.either: Requires both left and right functions");
        }
        return _maybe.caseOf({
          Nothing: f,
          Just: g
        }, x);
      }
      function concat(method) {
        return function(m) {
          if (!isSameType(Maybe, m)) {
            throw new TypeError("Maybe." + method + ": Maybe of Semigroup required");
          }
          return either(
            Maybe.Nothing,
            _innerConcat("Maybe." + method, m)
          );
        };
      }
      function coalesce(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Maybe.coalesce: Requires both left and right functions");
        }
        return Maybe.Just(either(f, g));
      }
      function bichain(l, r) {
        var bichainErr = "Maybe.bichain: Both arguments must be Maybe returning functions";
        if (!(isFunction(l) && isFunction(r))) {
          throw new TypeError(bichainErr);
        }
        var m = either(l, r);
        if (!isSameType(Maybe, m)) {
          throw new TypeError(bichainErr);
        }
        return m;
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Maybe." + method + ": Function required");
          }
          return either(
            Maybe.Nothing,
            compose(Maybe.Just, fn)
          );
        };
      }
      function alt(method) {
        return function(m) {
          if (!isSameType(Maybe, m)) {
            throw new TypeError("Maybe." + method + ": Maybe required");
          }
          return either(
            constant(m),
            Maybe.Just
          );
        };
      }
      function ap(m) {
        var fn = option(constant(void 0));
        if (!isFunction(fn)) {
          throw new TypeError("Maybe.ap: Wrapped value must be a function");
        } else if (!isSameType(Maybe, m)) {
          throw new TypeError("Maybe.ap: Maybe required");
        }
        return either(
          Maybe.Nothing,
          m.map
        );
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Maybe." + method + ": Function required");
          }
          var m = either(Maybe.Nothing, fn);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("Maybe." + method + ": Function must return a Maybe");
          }
          return m;
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Maybe.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        var af = apOrFunc(f);
        return either(
          compose(af, Maybe.Nothing),
          runSequence
        );
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Maybe.traverse: Applicative TypeRep or Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "Maybe.traverse: Apply returning function required for second argument"
          );
        }
        var af = apOrFunc(f);
        var m = either(compose(af, Maybe.Nothing), fn);
        if (!(isApply(m) || isArray(m))) {
          throw new TypeError(
            "Maybe.traverse: Both functions must return an Apply of the same type"
          );
        }
        return either(
          constant(m),
          constant(m.map(_of))
        );
      }
      return obj = {
        inspect,
        toString: inspect,
        either,
        option,
        type,
        equals,
        bichain,
        coalesce,
        zero,
        ap,
        of,
        sequence,
        traverse,
        alt: alt("alt"),
        chain: chain("chain"),
        concat: concat("concat"),
        map: map("map")
      }, obj[fl.zero] = zero, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.alt] = alt(fl.alt), obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Maybe, obj;
    }
    Maybe.of = _of;
    Maybe.zero = _zero;
    Maybe.type = type;
    Maybe[fl.of] = _of;
    Maybe[fl.zero] = _zero;
    Maybe["@@type"] = _type;
    Maybe["@@implements"] = _implements(
      ["alt", "ap", "chain", "concat", "equals", "map", "of", "traverse", "zero"]
    );
    module.exports = Maybe;
  }
});

// node_modules/crocks/core/List.js
var require_List = __commonJS({
  "node_modules/crocks/core/List.js"(exports, module) {
    var VERSION = 4;
    var _equals = require_equals();
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("List");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var array = require_array();
    var apOrFunc = require_apOrFunc();
    var isApplicative = require_isApplicative();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isFunction = require_isFunction();
    var isPredOrFunc = require_isPredOrFunc();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var predOrFunc = require_predOrFunc();
    var not = function(fn) {
      return function(x) {
        return !fn(x);
      };
    };
    var _prepend = function(x) {
      return function(m) {
        return x.concat(m);
      };
    };
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    var _of = function(x) {
      return List([x]);
    };
    var _empty = function() {
      return List([]);
    };
    function fromArray(xs) {
      if (!isArray(xs)) {
        throw new TypeError("List.fromArray: Array required");
      }
      return xs.reduce(function(res, x) {
        return res.concat(List.of(x));
      }, List.empty());
    }
    function applyTraverse(x, y) {
      if (isArray(x)) {
        return array.ap(x, array.map(function(v) {
          return _prepend(List.of(v));
        }, y));
      }
      return y.map(function(v) {
        return _prepend(List.of(v));
      }).ap(x);
    }
    function runSequence(acc, x) {
      if (!((isApply(acc) || isArray(acc)) && isSameType(acc, x))) {
        throw new TypeError(
          "List.sequence: Must wrap Applys of the same type"
        );
      }
      return applyTraverse(acc, x);
    }
    function runTraverse(f) {
      return function(acc, x) {
        var m = f(x);
        if (!((isApply(acc) || isArray(acc)) && isSameType(acc, m))) {
          throw new TypeError("List.traverse: Both functions must return an Apply of the same type");
        }
        return applyTraverse(acc, m);
      };
    }
    function List(x) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("List: List must wrap something");
      }
      var xs = isArray(x) ? x.slice() : [x];
      function flatMap(method, fn) {
        return function(y, x2) {
          var m = fn(x2);
          if (!isSameType(List, m)) {
            throw new TypeError("List." + method + ": Function must return a List");
          }
          return y.concat(m.valueOf());
        };
      }
      var of = _of;
      var valueOf = function() {
        return xs.slice();
      };
      var toArray = valueOf;
      var empty = _empty;
      var inspect = function() {
        return "List" + _inspect(xs);
      };
      var head = function() {
        return xs.length ? Just(xs[0]) : Nothing();
      };
      var tail = function() {
        return xs.length && xs.length > 1 ? Just(List(xs.slice(1))) : Nothing();
      };
      var cons = function(x2) {
        return List([x2].concat(xs));
      };
      var equals = function(m) {
        return isSameType(List, m) && _equals(xs, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(List, m)) {
            throw new TypeError("List." + method + ": List required");
          }
          return List(xs.concat(m.valueOf()));
        };
      }
      function reduce(method) {
        return function(fn, i) {
          if (!isFunction(fn)) {
            throw new TypeError("List." + method + ": Function required for first argument");
          }
          return xs.reduce(fn, i);
        };
      }
      function reduceRight(fn, i) {
        if (!isFunction(fn)) {
          throw new TypeError("List.reduceRight: Function required for first argument");
        }
        return xs.reduceRight(fn, i);
      }
      function fold() {
        if (isEmpty(xs)) {
          throw new TypeError("List.fold: List must contain at least one Semigroup");
        }
        var head2 = xs[0];
        if (!isSemigroup(head2)) {
          throw new TypeError("List.fold: List must contain Semigroups of the same type");
        }
        return xs.reduce(function(x2, y) {
          if (!isSameType(x2, y)) {
            throw new TypeError("List.fold: List must contain Semigroups of the same type");
          }
          return x2.concat(y);
        });
      }
      function foldMap(fn) {
        if (!isFunction(fn)) {
          throw new TypeError(
            "List.foldMap: Semigroup returning function required"
          );
        }
        if (isEmpty(xs)) {
          throw new TypeError(
            "List.foldMap: List must not be empty"
          );
        }
        var head2 = fn(xs[0]);
        if (!isSemigroup(head2)) {
          throw new TypeError(
            "List.foldMap: Provided function must return Semigroups of the same type"
          );
        }
        return xs.length !== 1 ? xs.slice(1).reduce(function(semi, x2) {
          var val = fn(x2);
          if (!(isSameType(semi, val) && isSemigroup(val))) {
            throw new TypeError(
              "List.foldMap: Provided function must return Semigroups of the same type"
            );
          }
          return semi.concat(val);
        }, head2) : head2;
      }
      function filter(method) {
        return function(pred) {
          if (!isPredOrFunc(pred)) {
            throw new TypeError("List." + method + ": Pred or predicate function required");
          }
          return List(
            xs.reduce(
              function(x2, y) {
                return predOrFunc(pred, y) ? x2.concat([y]) : x2;
              },
              []
            )
          );
        };
      }
      function reject(pred) {
        if (!isPredOrFunc(pred)) {
          throw new TypeError("List.reject: Pred or predicate function required");
        }
        var fn = not(function(x2) {
          return predOrFunc(pred, x2);
        });
        return List(
          xs.reduce(
            function(x2, y) {
              return fn(y) ? x2.concat([y]) : x2;
            },
            []
          )
        );
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("List." + method + ": Function required");
          }
          return List(xs.map(function(x2) {
            return fn(x2);
          }));
        };
      }
      function ap(m) {
        if (!isSameType(List, m)) {
          throw new TypeError("List.ap: List required");
        }
        var ar = m.valueOf();
        return List(
          xs.reduce(function(acc, fn) {
            if (!isFunction(fn)) {
              throw new TypeError("List.ap: Wrapped values must all be functions");
            }
            return acc.concat(ar.map(function(x2) {
              return fn(x2);
            }));
          }, [])
        );
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("List." + method + ": Function required");
          }
          return List(xs.reduce(flatMap(method, fn), []));
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "List.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        var af = apOrFunc(f);
        return reduceRight(
          runSequence,
          af(List.empty())
        );
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "List.traverse: Applicative TypeRep or Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "List.traverse: Apply returning functions required for second argument"
          );
        }
        var af = apOrFunc(f);
        return reduceRight(
          runTraverse(fn),
          af(List.empty())
        );
      }
      return obj = {
        inspect,
        toString: inspect,
        valueOf,
        toArray,
        head,
        tail,
        cons,
        type,
        equals,
        empty,
        reduceRight,
        fold,
        foldMap,
        reject,
        ap,
        of,
        sequence,
        traverse,
        concat: concat("concat"),
        map: map("map"),
        chain: chain("chain"),
        reduce: reduce("reduce"),
        filter: filter("filter")
      }, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.empty] = empty, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj[fl.reduce] = reduce(fl.reduce), obj[fl.filter] = filter(fl.filter), obj["@@type"] = _type, obj.constructor = List, obj;
    }
    List.of = _of;
    List.empty = _empty;
    List.type = type;
    List[fl.of] = _of;
    List[fl.empty] = _empty;
    List["@@type"] = _type;
    List.fromArray = fromArray;
    List["@@implements"] = _implements(
      ["ap", "chain", "concat", "empty", "equals", "map", "of", "reduce", "traverse"]
    );
    module.exports = List;
  }
});

// node_modules/crocks/List/index.js
var require_List2 = __commonJS({
  "node_modules/crocks/List/index.js"(exports, module) {
    module.exports = require_List();
  }
});

// node_modules/crocks/Maybe/index.js
var require_Maybe2 = __commonJS({
  "node_modules/crocks/Maybe/index.js"(exports, module) {
    module.exports = require_Maybe();
  }
});

// node_modules/crocks/core/Pair.js
var require_Pair = __commonJS({
  "node_modules/crocks/core/Pair.js"(exports, module) {
    var VERSION = 4;
    var _equals = require_equals();
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Pair");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isApplicative = require_isApplicative();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    function Pair(l, r) {
      var obj;
      if (arguments.length < 2) {
        throw new TypeError("Pair: Must provide a first and second value");
      }
      var fst = function() {
        return l;
      };
      var snd = function() {
        return r;
      };
      var inspect = function() {
        return "Pair(" + _inspect(l) + "," + _inspect(r) + " )";
      };
      var toArray = function() {
        return [l, r];
      };
      function merge(fn) {
        if (!isFunction(fn)) {
          throw new TypeError("Pair.merge: Binary function required");
        }
        return fn(fst(), snd());
      }
      function equals(m) {
        return isSameType(Pair, m) && _equals(m.fst(), fst()) && _equals(m.snd(), snd());
      }
      function concat(method) {
        return function(m) {
          if (!isSameType(Pair, m)) {
            throw new TypeError("Pair." + method + ": Pair required");
          }
          var lf = fst();
          var ls = snd();
          var rf = m.fst();
          var rs = m.snd();
          if (!(isSemigroup(lf) && isSemigroup(ls))) {
            throw new TypeError("Pair." + method + ": Both Pairs must contain Semigroups of the same type");
          }
          if (!(isSameType(lf, rf) && isSameType(ls, rs))) {
            throw new TypeError("Pair." + method + ": Both Pairs must contain Semigroups of the same type");
          }
          return Pair(
            lf.concat(rf),
            ls.concat(rs)
          );
        };
      }
      function swap(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Pair.swap: Requires both left and right functions");
        }
        return Pair(g(r), f(l));
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Pair." + method + ": Function required");
          }
          return Pair(l, fn(r));
        };
      }
      function bimap(method) {
        return function(f, g) {
          if (!isFunction(f) || !isFunction(g)) {
            throw new TypeError("Pair." + method + ": Function required for both arguments");
          }
          return Pair(f(l), g(r));
        };
      }
      function ap(m) {
        if (!isSameType(Pair, m)) {
          throw new TypeError("Pair.ap: Pair required");
        }
        var fn = snd();
        if (!isFunction(fn)) {
          throw new TypeError("Pair.ap: Function required for second value");
        }
        var l2 = fst();
        var r2 = m.fst();
        if (!(isSemigroup(l2) && isSameType(l2, r2))) {
          throw new TypeError("Pair.ap: Semigroups of the same type is required for first values");
        }
        return Pair(l2.concat(r2), fn(m.snd()));
      }
      function chain(method) {
        return function(fn) {
          var l2 = fst();
          if (!isFunction(fn)) {
            throw new TypeError("Pair." + method + ": Function required");
          }
          if (!isSemigroup(l2)) {
            throw new TypeError("Pair." + method + ": Semigroups of the same type required for first values");
          }
          var m = fn(snd());
          if (!isSameType(Pair, m)) {
            throw new TypeError("Pair." + method + ": Function must return a Pair");
          }
          var r2 = m.fst();
          if (!isSameType(l2, r2)) {
            throw new TypeError("Pair." + method + ": Semigroups of the same type required for first values");
          }
          return Pair(
            l2.concat(r2),
            m.snd()
          );
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Pair.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        if (!(isApply(r) || isArray(r))) {
          throw new TypeError(
            "Pair.sequence: Must wrap an Apply in the second"
          );
        }
        return r.map(function(v) {
          return Pair(l, v);
        });
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Pair.traverse: Applicative TypeRep or Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "Pair.traverse: Apply returning function required for second argument"
          );
        }
        var m = fn(r);
        if (!(isApply(m) || isArray(m))) {
          throw new TypeError(
            "Pair.traverse: Both functions must return an Apply of the same type"
          );
        }
        return m.map(function(v) {
          return Pair(l, v);
        });
      }
      function extend(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Pair." + method + ": Function required");
          }
          return Pair(l, fn(Pair(l, r)));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        fst,
        snd,
        toArray,
        type,
        merge,
        equals,
        swap,
        ap,
        sequence,
        traverse,
        concat: concat("concat"),
        map: map("map"),
        bimap: bimap("bimap"),
        chain: chain("chain"),
        extend: extend("extend")
      }, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.bimap] = bimap(fl.bimap), obj[fl.chain] = chain(fl.chain), obj[fl.extend] = extend(fl.extend), obj["@@type"] = _type, obj.constructor = Pair, obj;
    }
    Pair.type = type;
    Pair["@@type"] = _type;
    Pair["@@implements"] = _implements(
      ["ap", "bimap", "chain", "concat", "extend", "equals", "map", "traverse"]
    );
    module.exports = Pair;
  }
});

// node_modules/crocks/Pair/index.js
var require_Pair2 = __commonJS({
  "node_modules/crocks/Pair/index.js"(exports, module) {
    module.exports = require_Pair();
  }
});

// node_modules/crocks/core/Pred.js
var require_Pred = __commonJS({
  "node_modules/crocks/core/Pred.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Pred");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var compose = require_compose();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Pred(function() {
        return true;
      });
    };
    function Pred(pred) {
      var obj;
      if (!isFunction(pred)) {
        throw new TypeError("Pred: Predicate function required");
      }
      var runWith = function(x) {
        return !!pred(x);
      };
      var inspect = function() {
        return "Pred" + _inspect(runWith);
      };
      var empty = _empty;
      var valueOf = function() {
        return runWith;
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Pred, m)) {
            throw new TypeError("Pred." + method + ": Pred required");
          }
          return Pred(function(x) {
            return !!runWith(x) && !!m.runWith(x);
          });
        };
      }
      function contramap(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Pred." + method + ": Function required");
          }
          return Pred(compose(runWith, fn));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        runWith,
        type,
        valueOf,
        empty,
        concat: concat("concat"),
        contramap: contramap("contramap")
      }, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj[fl.contramap] = contramap(fl.contramap), obj["@@type"] = _type, obj.constructor = Pred, obj;
    }
    Pred.empty = _empty;
    Pred.type = type;
    Pred[fl.empty] = _empty;
    Pred["@@type"] = _type;
    Pred["@@implements"] = _implements(
      ["concat", "contramap", "empty"]
    );
    module.exports = Pred;
  }
});

// node_modules/crocks/Pred/index.js
var require_Pred2 = __commonJS({
  "node_modules/crocks/Pred/index.js"(exports, module) {
    module.exports = require_Pred();
  }
});

// node_modules/crocks/Reader/index.js
var require_Reader = __commonJS({
  "node_modules/crocks/Reader/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Reader");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var compose = require_compose();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _of = function(x) {
      return Reader(function() {
        return x;
      });
    };
    function ask(fn) {
      if (!arguments.length) {
        return Reader(function(x) {
          return x;
        });
      }
      if (isFunction(fn)) {
        return Reader(fn);
      }
      throw new TypeError("Reader.ask: No argument or function required");
    }
    function Reader(runWith) {
      var obj;
      if (!arguments.length || !isFunction(runWith)) {
        throw new TypeError("Reader: Must wrap a function");
      }
      var of = _of;
      var inspect = function() {
        return "Reader" + _inspect(runWith);
      };
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Reader." + method + ": Function required");
          }
          return Reader(compose(fn, runWith));
        };
      }
      function ap(m) {
        if (!isSameType(Reader, m)) {
          throw new TypeError("Reader.ap: Reader required");
        }
        return Reader(function(e) {
          var fn = runWith(e);
          if (!isFunction(fn)) {
            throw new TypeError("Reader.ap: Wrapped function must return a function");
          }
          return m.map(fn).runWith(e);
        });
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Reader." + method + ": Function required");
          }
          return Reader(function(e) {
            var m = fn(runWith(e));
            if (!isSameType(Reader, m)) {
              throw new TypeError("Reader." + method + ": Function must return a Reader");
            }
            return m.runWith(e);
          });
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        runWith,
        type,
        ap,
        of,
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Reader, obj;
    }
    Reader.of = _of;
    Reader.ask = ask;
    Reader.type = type;
    Reader[fl.of] = _of;
    Reader["@@type"] = _type;
    Reader["@@implements"] = _implements(
      ["ap", "chain", "map", "of"]
    );
    module.exports = Reader;
  }
});

// node_modules/crocks/Reader/ReaderT.js
var require_ReaderT = __commonJS({
  "node_modules/crocks/Reader/ReaderT.js"(exports, module) {
    var VERSION = 1;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _type = require_types().type("Reader")();
    var _typeString = require_types().typeFn(_type, VERSION);
    var fl = require_flNames();
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isMonad = require_isMonad();
    var isSameType = require_isSameType();
    function _ReaderT(Monad) {
      if (!isMonad(Monad)) {
        throw new TypeError("ReaderT: Monad required for construction");
      }
      var type = function() {
        return _type + "( " + Monad.type() + " )";
      };
      var typeString = _typeString + "( " + Monad["@@type"] + " )";
      var of = function(x) {
        return ReaderT(function() {
          return Monad.of(x);
        });
      };
      function ask(fn) {
        if (!arguments.length) {
          return ReaderT(Monad.of);
        }
        if (isFunction(fn)) {
          return ReaderT(Monad.of).map(fn);
        }
        throw new TypeError(type() + ".ask: No argument or function required");
      }
      function lift(m) {
        if (!isSameType(Monad, m)) {
          throw new TypeError(type() + ".lift: " + Monad.type() + " instance required");
        }
        return ReaderT(function() {
          return m;
        });
      }
      function liftFn(fn, x) {
        if (!isFunction(fn)) {
          throw new TypeError(type() + ".liftFn: " + Monad.type() + " returning function required");
        }
        return ReaderT(function() {
          var m = fn(x);
          if (!isSameType(Monad, m)) {
            throw new TypeError(type() + ".liftFn: " + Monad.type() + " returning function required");
          }
          return m;
        });
      }
      function ReaderT(wrapped) {
        var obj;
        if (!isFunction(wrapped)) {
          throw new TypeError(type() + ": " + Monad.type() + " returning function required");
        }
        var inspect = function() {
          return "" + type() + _inspect(wrapped);
        };
        function runWith(x) {
          var result = wrapped(x);
          if (!isSameType(Monad, result)) {
            throw new TypeError(type() + ": " + Monad.type() + " must be returned by wrapped function");
          }
          return result;
        }
        function map(fn) {
          if (!isFunction(fn)) {
            throw new TypeError(type() + ".map: Function required");
          }
          return ReaderT(function(e) {
            return runWith(e).map(fn);
          });
        }
        function ap(m) {
          if (!isSameType(ReaderT, m)) {
            throw new TypeError(type() + ".ap: " + type() + " required");
          }
          return ReaderT(function(e) {
            return runWith(e).ap(m.runWith(e));
          });
        }
        function chain(fn) {
          if (!isFunction(fn)) {
            throw new TypeError(type() + ".chain: " + type() + " returning function required");
          }
          return ReaderT(
            function(e) {
              return runWith(e).chain(function(inner) {
                var m = fn(inner);
                if (!isSameType(ReaderT, m)) {
                  throw new TypeError(type() + ".chain: Function must return a " + type());
                }
                return m.runWith(e);
              });
            }
          );
        }
        return obj = {
          inspect,
          toString: inspect,
          type,
          runWith,
          of,
          map,
          ap,
          chain
        }, obj[fl.of] = of, obj[fl.map] = map, obj[fl.chain] = chain, obj["@@type"] = typeString, obj.constructor = ReaderT, obj;
      }
      ReaderT.type = type;
      ReaderT.of = of;
      ReaderT.ask = ask;
      ReaderT.lift = lift;
      ReaderT.liftFn = curry(liftFn);
      ReaderT[fl.of] = of;
      ReaderT["@@type"] = typeString;
      ReaderT["@@implements"] = _implements(
        ["ap", "chain", "map", "of"]
      );
      return ReaderT;
    }
    module.exports = _ReaderT;
  }
});

// node_modules/crocks/Result/index.js
var require_Result = __commonJS({
  "node_modules/crocks/Result/index.js"(exports, module) {
    var VERSION = 4;
    var _defineUnion = require_defineUnion();
    var _equals = require_equals();
    var _implements = require_implements();
    var _innerConcat = require_innerConcat();
    var _inspect = require_inspect();
    var type = require_types().type("Result");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var apOrFunc = require_apOrFunc();
    var compose = require_compose();
    var isApplicative = require_isApplicative();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var _result = _defineUnion({ Err: ["a"], Ok: ["b"] });
    Result.Err = compose(Result, _result.Err);
    Result.Ok = compose(Result, _result.Ok);
    var _of = Result.Ok;
    var concatApErr = function(m) {
      return function(x) {
        return Result.Err(m.either(
          function(y) {
            return isSemigroup(x) && isSameType(y, x) ? x.concat(y) : x;
          },
          function() {
            return x;
          }
        ));
      };
    };
    var concatAltErr = function(r) {
      return function(l) {
        return Result.Err(isSemigroup(r) && isSameType(l, r) ? l.concat(r) : r);
      };
    };
    function runSequence(x) {
      if (!(isApply(x) || isArray(x))) {
        throw new TypeError(
          "Result.sequence: Must wrap an Apply"
        );
      }
      return x.map(_of);
    }
    function Result(u) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("Result: Must wrap something, try using Err or Ok constructors");
      }
      var x = !_result.includes(u) ? _result.Ok(u) : u;
      var equals = function(m) {
        return isSameType(Result, m) && either(
          function(x2) {
            return m.either(function(y) {
              return _equals(y, x2);
            }, constant(false));
          },
          function(x2) {
            return m.either(constant(false), function(y) {
              return _equals(y, x2);
            });
          }
        );
      };
      var of = _of;
      var inspect = function() {
        return either(
          function(l) {
            return "Err" + _inspect(l);
          },
          function(r) {
            return "Ok" + _inspect(r);
          }
        );
      };
      function either(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Result.either: Requires both invalid and valid functions");
        }
        return _result.caseOf({
          Err: f,
          Ok: g
        }, x);
      }
      function concat(method) {
        return function(m) {
          if (!isSameType(Result, m)) {
            throw new TypeError("Result." + method + ": Result of Semigroup required");
          }
          return either(
            Result.Err,
            _innerConcat("Result." + method, m)
          );
        };
      }
      function swap(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Result.swap: Requires both left and right functions");
        }
        return either(
          compose(Result.Ok, f),
          compose(Result.Err, g)
        );
      }
      function coalesce(f, g) {
        if (!isFunction(f) || !isFunction(g)) {
          throw new TypeError("Result.coalesce: Requires both left and right functions");
        }
        return Result.Ok(either(f, g));
      }
      function bichain(l, r) {
        var bichainErr = "Result.bichain: Both arguments must be Result returning functions";
        if (!(isFunction(l) && isFunction(r))) {
          throw new TypeError(bichainErr);
        }
        var m = either(l, r);
        if (!isSameType(Result, m)) {
          throw new TypeError(bichainErr);
        }
        return m;
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Result." + method + ": Function required");
          }
          return either(
            Result.Err,
            compose(Result.Ok, fn)
          );
        };
      }
      function bimap(method) {
        return function(f, g) {
          if (!isFunction(f) || !isFunction(g)) {
            throw new TypeError("Result." + method + ": Requires both left and right functions");
          }
          return either(
            compose(Result.Err, f),
            compose(Result.Ok, g)
          );
        };
      }
      function alt(method) {
        return function(m) {
          if (!isSameType(Result, m)) {
            throw new TypeError("Result." + method + ": Result required");
          }
          return m.either(
            function(r) {
              return either(concatAltErr(r), Result.Ok);
            },
            function(r) {
              return either(function() {
                return Result.Ok(r);
              }, Result.Ok);
            }
          );
        };
      }
      function ap(m) {
        if (!isSameType(Result, m)) {
          throw new TypeError("Result.ap: Result required");
        }
        return either(
          concatApErr(m),
          function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError("Result.ap: Wrapped value must be a function");
            }
            return m.either(Result.Err, function() {
              return m.map(fn);
            });
          }
        );
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Result." + method + ": Result returning function required");
          }
          var m = either(Result.Err, fn);
          if (!isSameType(Result, m)) {
            throw new TypeError("Result." + method + ": Function must return a Result");
          }
          return m;
        };
      }
      function sequence(f) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Result.sequence: Applicative TypeRep or Apply returning function required"
          );
        }
        var af = apOrFunc(f);
        return either(
          compose(af, Result.Err),
          runSequence
        );
      }
      function traverse(f, fn) {
        if (!(isApplicative(f) || isFunction(f))) {
          throw new TypeError(
            "Result.traverse: Applicative TypeRep of Apply returning function required for first argument"
          );
        }
        if (!isFunction(fn)) {
          throw new TypeError(
            "Result.traverse: Apply returning functions required for both arguments"
          );
        }
        var af = apOrFunc(f);
        var m = either(compose(af, Result.Err), fn);
        if (!(isApply(m) || isArray(m))) {
          throw new TypeError("Result.traverse: Both functions must return an Apply of the same type");
        }
        return either(
          constant(m),
          constant(m.map(_of))
        );
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        type,
        either,
        swap,
        coalesce,
        bichain,
        ap,
        of,
        sequence,
        traverse,
        alt: alt("alt"),
        bimap: bimap("bimap"),
        concat: concat("concat"),
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.alt] = alt(fl.alt), obj[fl.bimap] = bimap(fl.bimap), obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Result, obj;
    }
    Result.of = _of;
    Result.type = type;
    Result[fl.of] = _of;
    Result["@@type"] = _type;
    Result["@@implements"] = _implements(
      ["alt", "ap", "bimap", "chain", "concat", "equals", "map", "of", "traverse"]
    );
    module.exports = Result;
  }
});

// node_modules/crocks/Star/index.js
var require_Star = __commonJS({
  "node_modules/crocks/Star/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _type = require_types().type("Star");
    var __type = require_types().typeFn(_type(), VERSION);
    var fl = require_flNames();
    var array = require_array();
    var isFunction = require_isFunction();
    var isMonad = require_isMonad();
    var isSameType = require_isSameType();
    var Pair = require_Pair();
    var merge = function(fn, m) {
      return m.merge(fn);
    };
    var sequence = function(af, m) {
      return array.sequence(af, m);
    };
    function _Star(Monad) {
      if (!isMonad(Monad)) {
        throw new TypeError("Star: Monad required for construction");
      }
      var _id = function() {
        return Star(Monad.of);
      };
      var innerType = Monad.type();
      var innerFullType = Monad["@@type"];
      var outerType = _type() + "( " + innerType + " )";
      var typeString = __type + "( " + innerFullType + " )";
      var type = function() {
        return outerType;
      };
      function Star(runWith) {
        var obj;
        if (!isFunction(runWith)) {
          throw new TypeError(outerType + ": Function in the form (a -> m b) required");
        }
        var inspect = function() {
          return "" + outerType + _inspect(runWith);
        };
        var id = _id;
        function compose(method) {
          return function(s) {
            if (!isSameType(Star, s)) {
              throw new TypeError(outerType + "." + method + ": " + outerType + " required");
            }
            return Star(function(x) {
              var m = runWith(x);
              if (!isSameType(Monad, m)) {
                throw new TypeError(outerType + "." + method + ": Computations must return a type of " + innerType);
              }
              return m.chain(function(val) {
                var inner = s.runWith(val);
                if (!isSameType(m, inner)) {
                  throw new TypeError(outerType + "." + method + ": Both computations must return a type of " + innerType);
                }
                return inner;
              });
            });
          };
        }
        function map(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError(outerType + "." + method + ": Function required");
            }
            return Star(function(x) {
              var m = runWith(x);
              if (!isSameType(Monad, m)) {
                throw new TypeError(outerType + "." + method + ": Computations must return a type of " + innerType);
              }
              return m.map(fn);
            });
          };
        }
        function contramap(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError(outerType + "." + method + ": Function required");
            }
            return Star(function(x) {
              return runWith(fn(x));
            });
          };
        }
        function promap(method) {
          return function(l, r) {
            if (!isFunction(l) || !isFunction(r)) {
              throw new TypeError(outerType + "." + method + ": Functions required for both arguments");
            }
            return Star(function(x) {
              var m = runWith(l(x));
              if (!isSameType(Monad, m)) {
                throw new TypeError(outerType + "." + method + ": Computation must return a type of " + innerType);
              }
              return m.map(r);
            });
          };
        }
        function first() {
          return Star(function(x) {
            if (!isSameType(Pair, x)) {
              throw TypeError(outerType + ".first: Pair required for computation input");
            }
            var m = runWith(x.fst());
            if (!isSameType(Monad, m)) {
              throw new TypeError(outerType + ".first: Computation must return a type of " + innerType);
            }
            return m.map(function(l) {
              return Pair(l, x.snd());
            });
          });
        }
        function second() {
          return Star(function(x) {
            if (!isSameType(Pair, x)) {
              throw TypeError(outerType + ".second: Pair required for computation input");
            }
            var m = runWith(x.snd());
            if (!isSameType(Monad, m)) {
              throw new TypeError(outerType + ".second: Computation must return a type of " + innerType);
            }
            return m.map(function(r) {
              return Pair(x.fst(), r);
            });
          });
        }
        function both() {
          return Star(function(x) {
            if (!isSameType(Pair, x)) {
              throw TypeError(outerType + ".both: Pair required for computation input");
            }
            var p = x.bimap(runWith, runWith);
            var m = p.fst();
            if (!isSameType(Monad, m)) {
              throw new TypeError(outerType + ".both: Computation must return a type of " + innerType);
            }
            return sequence(m.of, merge(function(x2, y) {
              return [x2, y];
            }, p)).map(function(x2) {
              return Pair(x2[0], x2[1]);
            });
          });
        }
        return obj = {
          inspect,
          toString: inspect,
          type,
          runWith,
          id,
          first,
          second,
          both,
          compose: compose("compose"),
          contramap: contramap("contramap"),
          map: map("map"),
          promap: promap("promap")
        }, obj[fl.id] = id, obj[fl.compose] = compose(fl.compose), obj[fl.contramap] = contramap(fl.contramap), obj[fl.map] = map(fl.map), obj[fl.promap] = promap(fl.promap), obj["@@type"] = typeString, obj.constructor = Star, obj;
      }
      Star.id = _id;
      Star.type = type;
      Star[fl.id] = _id;
      Star["@@type"] = typeString;
      Star["@@implements"] = _implements(
        ["compose", "contramap", "id", "map", "promap"]
      );
      return Star;
    }
    module.exports = _Star;
  }
});

// node_modules/crocks/core/Unit.js
var require_Unit = __commonJS({
  "node_modules/crocks/core/Unit.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var type = require_types().type("Unit");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _of = Unit;
    var _empty = Unit;
    function Unit() {
      var obj;
      var equals = function(m) {
        return isSameType(Unit, m);
      };
      var inspect = function() {
        return "()";
      };
      var valueOf = function() {
        return void 0;
      };
      var of = _of;
      var empty = _empty;
      function concat(method) {
        return function(m) {
          if (!isSameType(Unit, m)) {
            throw new TypeError("Unit." + method + ": Unit required");
          }
          return Unit();
        };
      }
      function map(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Unit." + method + ": Function required");
          }
          return Unit();
        };
      }
      function ap(m) {
        if (!isSameType(Unit, m)) {
          throw new TypeError("Unit.ap: Unit required");
        }
        return Unit();
      }
      function chain(method) {
        return function(fn) {
          if (!isFunction(fn)) {
            throw new TypeError("Unit." + method + ": Function required");
          }
          return Unit();
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        valueOf,
        type,
        equals,
        empty,
        ap,
        of,
        concat: concat("concat"),
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.empty] = empty, obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = Unit, obj;
    }
    Unit.of = _of;
    Unit.empty = _empty;
    Unit.type = type;
    Unit[fl.of] = _of;
    Unit[fl.empty] = _empty;
    Unit["@@type"] = _type;
    Unit["@@implements"] = _implements(
      ["ap", "chain", "concat", "empty", "equals", "map", "of"]
    );
    module.exports = Unit;
  }
});

// node_modules/crocks/State/index.js
var require_State = __commonJS({
  "node_modules/crocks/State/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("State");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var Pair = require_Pair();
    var Unit = require_Unit();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _of = function(x) {
      return State(function(s) {
        return Pair(x, s);
      });
    };
    function get(fn) {
      if (!arguments.length) {
        return State(function(s) {
          return Pair(s, s);
        });
      }
      if (isFunction(fn)) {
        return State(function(s) {
          return Pair(fn(s), s);
        });
      }
      throw new TypeError("State.get: No arguments or function required");
    }
    function modify(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("State.modify: Function Required");
      }
      return State(function(s) {
        return Pair(Unit(), fn(s));
      });
    }
    function State(fn) {
      var obj;
      if (!isFunction(fn)) {
        throw new TypeError("State: Must wrap a function in the form (s -> Pair a s)");
      }
      var of = _of;
      var inspect = function() {
        return "State" + _inspect(fn);
      };
      function runWith(state) {
        var params = [], len = arguments.length - 1;
        while (len-- > 0)
          params[len] = arguments[len + 1];
        var func = params[0];
        if (func === void 0)
          func = "runWith";
        var m = fn(state);
        if (!isSameType(Pair, m)) {
          throw new TypeError("State." + func + ": Must wrap a function in the form (s -> Pair a s)");
        }
        return m;
      }
      function execWith(s) {
        var pair = runWith(s, "execWith");
        return pair.snd();
      }
      function evalWith(s) {
        var pair = runWith(s, "evalWith");
        return pair.fst();
      }
      function map(method) {
        return function(fn2) {
          if (!isFunction(fn2)) {
            throw new TypeError("State." + method + ": Function required");
          }
          return State(function(s) {
            var m = runWith(s, method);
            return Pair(fn2(m.fst()), m.snd());
          });
        };
      }
      function ap(m) {
        if (!isSameType(State, m)) {
          throw new TypeError("State.ap: State required");
        }
        return State(function(s) {
          var pair = runWith(s, "ap");
          var fn2 = pair.fst();
          if (!isFunction(fn2)) {
            throw new TypeError("State.ap: Source value must be a function");
          }
          return m.map(fn2).runWith(pair.snd());
        });
      }
      function chain(method) {
        return function(fn2) {
          if (!isFunction(fn2)) {
            throw new TypeError("State." + method + ": State returning function required");
          }
          return State(function(s) {
            var pair = runWith(s, method);
            var m = fn2(pair.fst());
            if (!isSameType(State, m)) {
              throw new TypeError("State." + method + ": Function must return another State");
            }
            return m.runWith(pair.snd());
          });
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        runWith,
        execWith,
        evalWith,
        type,
        ap,
        of,
        map: map("map"),
        chain: chain("chain")
      }, obj[fl.of] = of, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = _type, obj.constructor = State, obj;
    }
    State.of = _of;
    State.get = get;
    State.modify = modify;
    State.put = function(x) {
      return modify(function() {
        return x;
      });
    };
    State.type = type;
    State[fl.of] = _of;
    State["@@type"] = _type;
    State["@@implements"] = _implements(
      ["ap", "chain", "map", "of"]
    );
    module.exports = State;
  }
});

// node_modules/crocks/Tuple/index.js
var require_Tuple = __commonJS({
  "node_modules/crocks/Tuple/index.js"(exports, module) {
    var VERSION = 1;
    var _implements = require_implements();
    var _equals = require_equals();
    var _inspect = require_inspect();
    var _type = require_types().type("Tuple");
    var typeFn = require_types().typeFn;
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isInteger = require_isInteger();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    function _Tuple(n) {
      if (!(isInteger(n) && n >= 1)) {
        throw new TypeError("Tuple: First argument must be an integer");
      }
      var tupleLength = constant(n);
      var type = constant(_type(n));
      var typeString = typeFn("Tuple", VERSION, n);
      var withProps = function(fn) {
        fn.type = type;
        fn.tupleLength = tupleLength;
        fn["@@type"] = typeString;
        fn["@@implements"] = _implements(["map", "concat", "equals"]);
        return fn;
      };
      var withLength = function(n2, fn) {
        return Object.defineProperty(fn, "length", {
          value: n2
        });
      };
      switch (n) {
        case 1:
          return withProps(function(a) {
            return Tuple(n, arguments);
          });
        case 2:
          return withProps(function(a, b) {
            return Tuple(n, arguments);
          });
        case 3:
          return withProps(function(a, b, c) {
            return Tuple(n, arguments);
          });
        case 4:
          return withProps(function(a, b, c, d) {
            return Tuple(n, arguments);
          });
        case 5:
          return withProps(function(a, b, c, d, e) {
            return Tuple(n, arguments);
          });
        case 6:
          return withProps(function(a, b, c, d, e, f) {
            return Tuple(n, arguments);
          });
        case 7:
          return withProps(function(a, b, c, d, e, f, g) {
            return Tuple(n, arguments);
          });
        case 8:
          return withProps(function(a, b, c, d, e, f, g, h) {
            return Tuple(n, arguments);
          });
        case 9:
          return withProps(function(a, b, c, d, e, f, g, h, i) {
            return Tuple(n, arguments);
          });
        case 10:
          return withProps(function(a, b, c, d, e, f, g, h, i, j) {
            return Tuple(n, arguments);
          });
        default:
          return withLength(n, withProps(function() {
            var parts = [], len = arguments.length;
            while (len--)
              parts[len] = arguments[len];
            return Tuple(n, parts);
          }));
      }
      function Tuple(n2, args) {
        var obj;
        var parts = [].slice.call(args);
        if (n2 !== parts.length) {
          throw new TypeError(
            n2 + "-Tuple: Expected " + n2 + " values, but got " + parts.length
          );
        }
        var inspect = function() {
          return n2 + "-Tuple(" + parts.map(_inspect).join(",") + " )";
        };
        function map(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError(n2 + "-Tuple." + method + ": Function required");
            }
            return Tuple(
              n2,
              parts.slice(0, parts.length - 1).concat(fn(parts[parts.length - 1]))
            );
          };
        }
        var equals = function(m) {
          return isSameType({ type }, m) && _equals(parts, m.toArray());
        };
        function concat(method) {
          return function(t) {
            if (!isSameType({ type }, t)) {
              throw new TypeError(n2 + "-Tuple." + method + ": Tuple of the same length required");
            }
            var a = t.toArray();
            return Tuple(n2, parts.map(function(v, i, o) {
              if (!(isSemigroup(a[i]) && isSemigroup(o[i]))) {
                throw new TypeError(
                  n2 + "-Tuple." + method + ": Both Tuples must contain Semigroups of the same type"
                );
              }
              if (!isSameType(a[i], o[i])) {
                throw new TypeError(
                  n2 + "-Tuple." + method + ": Both Tuples must contain Semigroups of the same type"
                );
              }
              return o[i].concat(a[i]);
            }));
          };
        }
        function merge(fn) {
          if (!isFunction(fn)) {
            throw new TypeError(n2 + "-Tuple.merge: Function required");
          }
          return fn.apply(void 0, parts);
        }
        function mapAll() {
          var args2 = [], len = arguments.length;
          while (len--)
            args2[len] = arguments[len];
          if (args2.length !== parts.length) {
            throw new TypeError(
              n2 + "-Tuple.mapAll: Requires " + parts.length + " functions"
            );
          }
          return Tuple(
            n2,
            parts.map(function(v, i) {
              if (!isFunction(args2[i])) {
                throw new TypeError(
                  n2 + "-Tuple.mapAll: Functions required for all arguments"
                );
              }
              return args2[i](v);
            })
          );
        }
        function project(index) {
          if (!isInteger(index) || index < 1 || index > n2) {
            throw new TypeError(
              n2 + "-Tuple.project: Index should be an integer between 1 and " + n2
            );
          }
          return parts[index - 1];
        }
        function toArray() {
          return parts.slice();
        }
        return obj = {
          inspect,
          toString: inspect,
          merge,
          project,
          mapAll,
          toArray,
          tupleLength,
          type,
          equals,
          map: map("map"),
          concat: concat("concat")
        }, obj[fl.map] = map(fl.map), obj[fl.concat] = concat(fl.concat), obj[fl.equals] = equals, obj["@@type"] = typeString, obj.constructor = Tuple, obj;
      }
    }
    module.exports = _Tuple;
  }
});

// node_modules/crocks/Unit/index.js
var require_Unit2 = __commonJS({
  "node_modules/crocks/Unit/index.js"(exports, module) {
    module.exports = require_Unit();
  }
});

// node_modules/crocks/Writer/index.js
var require_Writer = __commonJS({
  "node_modules/crocks/Writer/index.js"(exports, module) {
    var VERSION = 2;
    var _equals = require_equals();
    var _implements = require_implements();
    var _inspect = require_inspect();
    var __type = require_types().type("Writer")();
    var _typeString = require_types().typeFn(__type, VERSION);
    var fl = require_flNames();
    var Pair = require_Pair();
    var isFunction = require_isFunction();
    var isMonoid = require_isMonoid();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    function _Writer(Monoid) {
      if (!isMonoid(Monoid)) {
        throw new TypeError("Writer: Monoid required for construction");
      }
      var _of = function(x) {
        return Writer(Monoid.empty().valueOf(), x);
      };
      var _type = constant(__type + "( " + Monoid.type() + " )");
      var typeString = _typeString + "( " + Monoid["@@type"] + " )";
      function Writer(entry, val) {
        var obj;
        if (arguments.length !== 2) {
          throw new TypeError("Writer: Log entry and a value required");
        }
        var type = _type;
        var of = _of;
        var equals = function(m) {
          return isSameType(Writer, m) && _equals(m.valueOf(), val);
        };
        var valueOf = constant(val);
        var log = constant(Monoid(entry));
        var inspect = constant("Writer(" + _inspect(log()) + _inspect(valueOf()) + " )");
        var read = function() {
          return Pair(log(), val);
        };
        function map(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError("Writer." + method + ": Function required");
            }
            return Writer(log().valueOf(), fn(valueOf()));
          };
        }
        function ap(m) {
          if (!isFunction(val)) {
            throw new TypeError("Writer.ap: Wrapped value must be a function");
          }
          if (!isSameType(Writer, m)) {
            throw new TypeError("Writer.ap: Writer required");
          }
          return Writer(
            log().concat(m.log()).valueOf(),
            val(m.valueOf())
          );
        }
        function chain(method) {
          return function(fn) {
            if (!isFunction(fn)) {
              throw new TypeError("Writer." + method + ": Function required");
            }
            var w = fn(valueOf());
            if (!isSameType(Writer, w)) {
              throw new TypeError("Writer." + method + ": Function must return a Writer");
            }
            return Writer(log().concat(w.log()).valueOf(), w.valueOf());
          };
        }
        return obj = {
          inspect,
          toString: inspect,
          read,
          valueOf,
          log,
          type,
          equals,
          ap,
          of,
          chain: chain("chain"),
          map: map("map")
        }, obj[fl.of] = of, obj[fl.equals] = equals, obj[fl.map] = map(fl.map), obj[fl.chain] = chain(fl.chain), obj["@@type"] = typeString, obj.constructor = Writer, obj;
      }
      Writer.of = _of;
      Writer.type = _type;
      Writer[fl.of] = _of;
      Writer["@@type"] = typeString;
      Writer["@@implements"] = _implements(
        ["ap", "chain", "equals", "map", "of"]
      );
      return Writer;
    }
    module.exports = _Writer;
  }
});

// node_modules/crocks/core/object.js
var require_object = __commonJS({
  "node_modules/crocks/core/object.js"(exports, module) {
    function rejectUnit(obj) {
      return function(acc, key) {
        var value = obj[key];
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      };
    }
    function assign(x, m) {
      var result = Object.keys(m).reduce(rejectUnit(m), {});
      return Object.keys(x).reduce(rejectUnit(x), result);
    }
    function filter(f, m) {
      return Object.keys(m).reduce(function(acc, key) {
        if (f(m[key])) {
          acc[key] = m[key];
        }
        return acc;
      }, {});
    }
    function map(f, m) {
      return Object.keys(m).reduce(function(acc, key) {
        acc[key] = f(m[key]);
        return acc;
      }, {});
    }
    function set(key, val, m) {
      var obj;
      return assign((obj = {}, obj[key] = val, obj), m);
    }
    function unset(key, m) {
      return Object.keys(m).reduce(function(acc, k) {
        if (m[k] !== void 0 && k !== key) {
          acc[k] = m[k];
        }
        return acc;
      }, {});
    }
    module.exports = {
      assign,
      filter,
      map,
      set,
      unset
    };
  }
});

// node_modules/crocks/helpers/assign.js
var require_assign = __commonJS({
  "node_modules/crocks/helpers/assign.js"(exports, module) {
    var curry = require_curry();
    var isObject = require_isObject();
    var object = require_object();
    function assign(x, m) {
      if (!(isObject(x) && isObject(m))) {
        throw new TypeError("assign: Objects required for both arguments");
      }
      return object.assign(x, m);
    }
    module.exports = curry(assign);
  }
});

// node_modules/crocks/helpers/setProp.js
var require_setProp = __commonJS({
  "node_modules/crocks/helpers/setProp.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isInteger = require_isInteger();
    var isObject = require_isObject();
    var isString = require_isString();
    var array = require_array();
    var object = require_object();
    function fn(name) {
      function setProp2(key, val, x) {
        if (isObject(x)) {
          if (isString(key)) {
            return object.set(key, val, x);
          }
          throw new TypeError(
            name + ": String required for first argument when third argument is an Object"
          );
        }
        if (isArray(x)) {
          if (isInteger(key) && key >= 0) {
            return array.set(key, val, x);
          }
          throw new TypeError(
            name + ": Positive Integer required for first argument when third argument is an Array"
          );
        }
        throw new TypeError(
          name + ": Object or Array required for third argument"
        );
      }
      return curry(setProp2);
    }
    var setProp = fn("setProp");
    setProp.origFn = fn;
    module.exports = setProp;
  }
});

// node_modules/crocks/helpers/assoc.js
var require_assoc = __commonJS({
  "node_modules/crocks/helpers/assoc.js"(exports, module) {
    var setProp = require_setProp();
    module.exports = setProp.origFn("assoc");
  }
});

// node_modules/crocks/core/curryN.js
var require_curryN = __commonJS({
  "node_modules/crocks/core/curryN.js"(exports, module) {
    function curryN(n, fn) {
      return function() {
        var xs = [], len = arguments.length;
        while (len--)
          xs[len] = arguments[len];
        var args = xs.length ? xs : [void 0];
        var remaining = Math.floor(n) - args.length;
        return remaining > 0 ? curryN(remaining, Function.bind.apply(fn, [null].concat(args))) : fn.apply(null, args.slice(0, n));
      };
    }
    module.exports = curryN;
  }
});

// node_modules/crocks/helpers/binary.js
var require_binary = __commonJS({
  "node_modules/crocks/helpers/binary.js"(exports, module) {
    var curryN = require_curryN();
    var isFunction = require_isFunction();
    function binary(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("binary: Function required");
      }
      return curryN(2, fn);
    }
    module.exports = binary;
  }
});

// node_modules/crocks/helpers/compose.js
var require_compose3 = __commonJS({
  "node_modules/crocks/helpers/compose.js"(exports, module) {
    var isFunction = require_isFunction();
    var err = "compose: Functions required";
    function applyPipe(f, g) {
      if (!isFunction(g)) {
        throw new TypeError(err);
      }
      return function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        return g.call(null, f.apply(null, args));
      };
    }
    function compose() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var fns = args.slice().reverse();
      var head = fns[0];
      if (!isFunction(head)) {
        throw new TypeError(err);
      }
      var tail = fns.slice(1).concat(function(x) {
        return x;
      });
      return tail.reduce(applyPipe, head);
    }
    module.exports = compose;
  }
});

// node_modules/crocks/helpers/composeK.js
var require_composeK = __commonJS({
  "node_modules/crocks/helpers/composeK.js"(exports, module) {
    var isChain = require_isChain();
    var isFunction = require_isFunction();
    var err = "composeK: Chain returning functions of the same type required";
    function composeK() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var fns = args.slice().reverse();
      var head = fns[0];
      if (!isFunction(head)) {
        throw new TypeError(err);
      }
      if (fns.length === 1) {
        return head;
      }
      var tail = fns.slice(1).reduce(function(comp, fn) {
        if (!isFunction(fn)) {
          throw new TypeError(err);
        }
        return function(m) {
          if (!isChain(m)) {
            throw new TypeError(err);
          }
          return comp(m).chain(fn);
        };
      }, function(x) {
        return x;
      });
      return function() {
        return tail(head.apply(null, arguments));
      };
    }
    module.exports = composeK;
  }
});

// node_modules/crocks/helpers/composeP.js
var require_composeP = __commonJS({
  "node_modules/crocks/helpers/composeP.js"(exports, module) {
    var isFunction = require_isFunction();
    var isPromise = require_isPromise();
    var err = "composeP: Promise returning functions required";
    function applyPipe(f, g) {
      if (!isFunction(g)) {
        throw new TypeError(err);
      }
      return function() {
        var p = f.apply(null, arguments);
        if (!isPromise(p)) {
          throw new TypeError(err);
        }
        return p.then(g);
      };
    }
    function composeP() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var fns = args.reverse();
      var head = fns[0];
      if (!isFunction(head)) {
        throw new TypeError(err);
      }
      var tail = fns.slice(1).concat(function(x) {
        return x;
      });
      return tail.reduce(applyPipe, head);
    }
    module.exports = composeP;
  }
});

// node_modules/crocks/helpers/composeS.js
var require_composeS = __commonJS({
  "node_modules/crocks/helpers/composeS.js"(exports, module) {
    var isSameType = require_isSameType();
    var isSemigroupoid = require_isSemigroupoid();
    var err = "composeS: Semigroupoids of the same type required";
    function composeS() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var ms = args.slice().reverse();
      var head = ms[0];
      if (!isSemigroupoid(head)) {
        throw new TypeError(err);
      }
      if (ms.length === 1) {
        return head;
      }
      return ms.slice().reduce(function(comp, m) {
        if (!isSameType(comp, m)) {
          throw new TypeError(err);
        }
        return comp.compose(m);
      });
    }
    module.exports = composeS;
  }
});

// node_modules/crocks/helpers/curry.js
var require_curry2 = __commonJS({
  "node_modules/crocks/helpers/curry.js"(exports, module) {
    var _curry = require_curry();
    var isFunction = require_isFunction();
    function curry(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("curry: Function required");
      }
      return _curry(fn);
    }
    module.exports = curry;
  }
});

// node_modules/crocks/helpers/defaultProps.js
var require_defaultProps = __commonJS({
  "node_modules/crocks/helpers/defaultProps.js"(exports, module) {
    var curry = require_curry();
    var isObject = require_isObject();
    var object = require_object();
    function defaultProps(x, m) {
      if (!isObject(x) || !isObject(m)) {
        throw new TypeError("defaultProps: Objects required for both arguments");
      }
      return object.assign(m, x);
    }
    module.exports = curry(defaultProps);
  }
});

// node_modules/crocks/helpers/defaultTo.js
var require_defaultTo = __commonJS({
  "node_modules/crocks/helpers/defaultTo.js"(exports, module) {
    var curry = require_curry();
    var isNil = require_isNil();
    function defaultTo(def, val) {
      return isNil(val) ? def : val;
    }
    module.exports = curry(defaultTo);
  }
});

// node_modules/crocks/helpers/unsetProp.js
var require_unsetProp = __commonJS({
  "node_modules/crocks/helpers/unsetProp.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isObject = require_isObject();
    var isString = require_isString();
    var array = require_array();
    var object = require_object();
    function fn(name) {
      function unsetProp2(key, obj) {
        if (!(isObject(obj) || isArray(obj))) {
          return obj;
        }
        if (!(isString(key) && !isEmpty(key) || isInteger(key) && key >= 0)) {
          throw new TypeError(
            name + ": Non-empty String required or Positive Integer required for first argument"
          );
        }
        if (isObject(obj)) {
          if (isString(key) && !isEmpty(key)) {
            return object.unset(key, obj);
          }
        }
        if (isArray(obj)) {
          if (isInteger(key) && key >= 0) {
            return array.unset(key, obj);
          }
        }
        return obj;
      }
      return curry(unsetProp2);
    }
    var unsetProp = fn("unsetProp");
    unsetProp.origFn = fn;
    module.exports = unsetProp;
  }
});

// node_modules/crocks/helpers/dissoc.js
var require_dissoc = __commonJS({
  "node_modules/crocks/helpers/dissoc.js"(exports, module) {
    var unsetProp = require_unsetProp();
    module.exports = unsetProp.origFn("dissoc");
  }
});

// node_modules/crocks/helpers/fromPairs.js
var require_fromPairs = __commonJS({
  "node_modules/crocks/helpers/fromPairs.js"(exports, module) {
    var Pair = require_types().proxy("Pair");
    var isFoldable = require_isFoldable();
    var isSameType = require_isSameType();
    var isString = require_isString();
    function foldPairs(acc, pair) {
      var obj;
      if (!isSameType(Pair, pair)) {
        throw new TypeError("fromPairs: Foldable of Pairs required for argument");
      }
      var key = pair.fst();
      var value = pair.snd();
      if (!isString(key)) {
        throw new TypeError("fromPairs: String required for fst of every Pair");
      }
      return value !== void 0 ? Object.assign(acc, (obj = {}, obj[key] = value, obj)) : acc;
    }
    function fromPairs(xs) {
      if (!isFoldable(xs)) {
        throw new TypeError("fromPairs: Foldable of Pairs required for argument");
      }
      return xs.reduce(foldPairs, {});
    }
    module.exports = fromPairs;
  }
});

// node_modules/crocks/helpers/getPathOr.js
var require_getPathOr = __commonJS({
  "node_modules/crocks/helpers/getPathOr.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    var errFn = function(name) {
      return name + ": Array of Non-empty Strings or Integers required for second argument";
    };
    function fn(name) {
      function getPathOr2(def, keys, target) {
        if (!isArray(keys)) {
          throw new TypeError(errFn(name));
        }
        if (isNil(target)) {
          return def;
        }
        var value = target;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
            throw new TypeError(errFn(name));
          }
          if (isNil(value)) {
            return def;
          }
          value = value[key];
          if (!isDefined(value)) {
            return def;
          }
        }
        return value;
      }
      return curry(getPathOr2);
    }
    var getPathOr = fn("getPathOr");
    getPathOr.origFn = fn;
    module.exports = getPathOr;
  }
});

// node_modules/crocks/helpers/liftA2.js
var require_liftA2 = __commonJS({
  "node_modules/crocks/helpers/liftA2.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var map = array.map;
    var ap = array.ap;
    function liftA2(fn, x, y) {
      if (!isFunction(fn)) {
        throw new TypeError("liftA2: Function required for first argument");
      }
      if (!((isApply(x) || isArray(x)) && isSameType(x, y))) {
        throw new TypeError("liftA2: Applys of same type required for last two arguments");
      }
      if (isArray(x)) {
        return ap(y, map(fn, x));
      }
      return x.map(fn).ap(y);
    }
    module.exports = curry(liftA2);
  }
});

// node_modules/crocks/helpers/liftA3.js
var require_liftA3 = __commonJS({
  "node_modules/crocks/helpers/liftA3.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var map = array.map;
    var ap = array.ap;
    function liftA3(fn, x, y, z) {
      if (!isFunction(fn)) {
        throw new TypeError("liftA3: Function required for first argument");
      } else if (!((isApply(x) || isArray(x)) && isSameType(x, y) && isSameType(x, z))) {
        throw new TypeError("liftA3: Applys of same type required for last three arguments");
      }
      if (isArray(x)) {
        return ap(z, ap(y, map(fn, x)));
      }
      return x.map(fn).ap(y).ap(z);
    }
    module.exports = curry(liftA3);
  }
});

// node_modules/crocks/helpers/liftN.js
var require_liftN = __commonJS({
  "node_modules/crocks/helpers/liftN.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var curryN = require_curryN();
    var isApply = require_isApply();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isFunctor = require_isFunctor();
    var isInteger = require_isInteger();
    var isSameType = require_isSameType();
    var ap = array.ap;
    var applyAp = function(x, y) {
      if (!(isSameType(x, y) && (isArray(y) || isApply(y)))) {
        throw new TypeError("liftN: Applys of same type are required");
      }
      if (isArray(x)) {
        return ap(y, x);
      }
      return x.ap(y);
    };
    function liftN(n, fn) {
      if (!isInteger(n)) {
        throw new TypeError("liftN: Integer required for first argument");
      }
      if (!isFunction(fn)) {
        throw new TypeError("liftN: Function required for second argument");
      }
      return curryN(n, function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        if (!isFunctor(args[0])) {
          throw new TypeError("liftN: Applys of same type are required");
        }
        return args.slice(1, n).reduce(
          applyAp,
          args[0].map(function(x) {
            return curryN(n, fn)(x);
          })
        );
      });
    }
    module.exports = curry(liftN);
  }
});

// node_modules/crocks/helpers/getPropOr.js
var require_getPropOr = __commonJS({
  "node_modules/crocks/helpers/getPropOr.js"(exports, module) {
    var curry = require_curry();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    function fn(name) {
      function getPropOr2(def, key, target) {
        if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
          throw new TypeError(name + ": Non-empty String or Integer required for second argument");
        }
        if (isNil(target)) {
          return def;
        }
        var value = target[key];
        return isDefined(value) ? value : def;
      }
      return curry(getPropOr2);
    }
    var getPropOr = fn("getPropOr");
    getPropOr.origFn = fn;
    module.exports = getPropOr;
  }
});

// node_modules/crocks/helpers/mapProps.js
var require_mapProps = __commonJS({
  "node_modules/crocks/helpers/mapProps.js"(exports, module) {
    var curry = require_curry();
    var isObject = require_isObject();
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    var applyMap = function(fns, obj) {
      return function(acc, key) {
        var obj$1, obj$2, obj$3;
        if (isNil(fns[key])) {
          return Object.assign({}, acc, (obj$1 = {}, obj$1[key] = obj[key], obj$1));
        }
        if (isObject(fns[key])) {
          return Object.assign({}, acc, (obj$2 = {}, obj$2[key] = isObject(obj[key]) ? mapProps(fns[key], obj[key]) : obj[key], obj$2));
        }
        if (!isFunction(fns[key])) {
          throw new TypeError("mapProps: Object of functions required for first argument");
        }
        return Object.assign({}, acc, (obj$3 = {}, obj$3[key] = fns[key](obj[key]), obj$3));
      };
    };
    function mapProps(fns, obj) {
      if (!(isObject(fns) && isObject(obj))) {
        throw new TypeError("mapProps: Objects required for both arguments");
      }
      return Object.keys(obj).reduce(applyMap(fns, obj), {});
    }
    module.exports = curry(mapProps);
  }
});

// node_modules/crocks/helpers/mapReduce.js
var require_mapReduce = __commonJS({
  "node_modules/crocks/helpers/mapReduce.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isFunction = require_isFunction();
    function mapReduce(mapFn, reduceFn, empty, xs) {
      if (!isFunction(mapFn)) {
        throw new TypeError("mapReduce: Unary mapping function required for first argument");
      }
      if (!isFunction(reduceFn)) {
        throw new TypeError("mapReduce: Binary reduction function required for second argument");
      }
      if (!isFoldable(xs)) {
        throw new TypeError("mapReduce: Foldable required for fourth argument");
      }
      return xs.reduce(
        function(acc, x) {
          return reduceFn(acc, mapFn(x));
        },
        empty
      );
    }
    module.exports = curry(mapReduce);
  }
});

// node_modules/crocks/core/mconcatMap.js
var require_mconcatMap = __commonJS({
  "node_modules/crocks/core/mconcatMap.js"(exports, module) {
    var compose = require_compose();
    var foldWith = function(m) {
      return function(x, y) {
        return x.concat(m(y));
      };
    };
    function mconcatMap(M, f, xs) {
      return xs.reduce(foldWith(compose(M, f)), M.empty());
    }
    module.exports = mconcatMap;
  }
});

// node_modules/crocks/helpers/mconcat.js
var require_mconcat = __commonJS({
  "node_modules/crocks/helpers/mconcat.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isMonoid = require_isMonoid();
    var mconcatMap = require_mconcatMap();
    var identity = function(x) {
      return x;
    };
    function mconcat(m, xs) {
      if (!isMonoid(m)) {
        throw new TypeError(
          "mconcat: Monoid required for first argument"
        );
      }
      if (!isFoldable(xs)) {
        throw new TypeError(
          "mconcat: Foldable required for second argument"
        );
      }
      return mconcatMap(m, identity, xs);
    }
    module.exports = curry(mconcat);
  }
});

// node_modules/crocks/helpers/mconcatMap.js
var require_mconcatMap2 = __commonJS({
  "node_modules/crocks/helpers/mconcatMap.js"(exports, module) {
    var _mconcatMap = require_mconcatMap();
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isFunction = require_isFunction();
    var isMonoid = require_isMonoid();
    function mconcatMap(m, f, xs) {
      if (!isMonoid(m)) {
        throw new TypeError(
          "mconcatMap: Monoid required for first argument"
        );
      }
      if (!isFunction(f)) {
        throw new TypeError(
          "mconcatMap: Function required for second argument"
        );
      }
      if (!isFoldable(xs)) {
        throw new TypeError(
          "mconcatMap: Foldable required for third argument"
        );
      }
      return _mconcatMap(m, f, xs);
    }
    module.exports = curry(mconcatMap);
  }
});

// node_modules/crocks/helpers/mreduce.js
var require_mreduce = __commonJS({
  "node_modules/crocks/helpers/mreduce.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isMonoid = require_isMonoid();
    var mconcatMap = require_mconcatMap();
    var identity = function(x) {
      return x;
    };
    function mreduce(m, xs) {
      if (!isMonoid(m)) {
        throw new TypeError(
          "mreduce: Monoid required for first argument"
        );
      }
      if (!isFoldable(xs)) {
        throw new TypeError(
          "mreduce: Foldable required for second argument"
        );
      }
      return mconcatMap(m, identity, xs).valueOf();
    }
    module.exports = curry(mreduce);
  }
});

// node_modules/crocks/helpers/mreduceMap.js
var require_mreduceMap = __commonJS({
  "node_modules/crocks/helpers/mreduceMap.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isFunction = require_isFunction();
    var isMonoid = require_isMonoid();
    var mconcatMap = require_mconcatMap();
    function mreduceMap(m, f, xs) {
      if (!isMonoid(m)) {
        throw new TypeError(
          "mreduceMap: Monoid required for first argument"
        );
      }
      if (!isFunction(f)) {
        throw new TypeError(
          "mreduceMap: Function required for second argument"
        );
      }
      if (!isFoldable(xs)) {
        throw new TypeError(
          "mreduceMap: Foldable required for third argument"
        );
      }
      return mconcatMap(m, f, xs).valueOf();
    }
    module.exports = curry(mreduceMap);
  }
});

// node_modules/crocks/helpers/nAry.js
var require_nAry = __commonJS({
  "node_modules/crocks/helpers/nAry.js"(exports, module) {
    var curry = require_curry();
    var curryN = require_curryN();
    var isFunction = require_isFunction();
    var isNumber = require_isNumber();
    function nAry(num, fn) {
      if (!isNumber(num)) {
        throw new TypeError("nAry: Number required for first argument");
      }
      if (!isFunction(fn)) {
        throw new TypeError("nAry: Function required for second argument");
      }
      return curryN(num, fn);
    }
    module.exports = curry(nAry);
  }
});

// node_modules/crocks/helpers/objOf.js
var require_objOf = __commonJS({
  "node_modules/crocks/helpers/objOf.js"(exports, module) {
    var curry = require_curry();
    var isString = require_isString();
    function objOf(key, value) {
      var obj;
      if (!(key && isString(key))) {
        throw new TypeError("objOf: Non-empty String required for first argument");
      }
      return obj = {}, obj[key] = value, obj;
    }
    module.exports = curry(objOf);
  }
});

// node_modules/crocks/helpers/omit.js
var require_omit = __commonJS({
  "node_modules/crocks/helpers/omit.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isObject = require_isObject();
    function omitKeys(keys, obj) {
      return function(acc, key) {
        var obj$1;
        return keys.indexOf(key) === -1 && obj[key] !== void 0 ? Object.assign(acc, (obj$1 = {}, obj$1[key] = obj[key], obj$1)) : acc;
      };
    }
    function omit(keys, obj) {
      if (!isFoldable(keys)) {
        throw new TypeError("omit: Foldable required for first argument");
      } else if (!isObject(obj)) {
        throw new TypeError("omit: Object required for second argument");
      }
      return Object.keys(obj).reduce(omitKeys(keys, obj), {});
    }
    module.exports = curry(omit);
  }
});

// node_modules/crocks/helpers/once.js
var require_once2 = __commonJS({
  "node_modules/crocks/helpers/once.js"(exports, module) {
    var isFunction = require_isFunction();
    var _once = require_once();
    function once(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("once: Function required");
      }
      return _once(fn);
    }
    module.exports = once;
  }
});

// node_modules/crocks/helpers/partial.js
var require_partial = __commonJS({
  "node_modules/crocks/helpers/partial.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function partial() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var fn = args[0];
      var xs = args.slice(1);
      if (!isFunction(fn)) {
        throw new TypeError("partial: Function required for first argument");
      }
      return curry(
        Function.bind.apply(fn, [null].concat(xs))
      );
    }
    module.exports = partial;
  }
});

// node_modules/crocks/helpers/pick.js
var require_pick = __commonJS({
  "node_modules/crocks/helpers/pick.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isObject = require_isObject();
    var isString = require_isString();
    function pickKeys(obj) {
      return function(acc, key) {
        var obj$1;
        if (!isString(key)) {
          throw new TypeError("pick: Foldable of Strings is required for first argument");
        }
        return key && obj[key] !== void 0 ? Object.assign(acc, (obj$1 = {}, obj$1[key] = obj[key], obj$1)) : acc;
      };
    }
    function pick(keys, obj) {
      if (!isFoldable(keys)) {
        throw new TypeError("pick: Foldable required for first argument");
      } else if (!isObject(obj)) {
        throw new TypeError("pick: Object required for second argument");
      }
      return keys.reduce(pickKeys(obj), {});
    }
    module.exports = curry(pick);
  }
});

// node_modules/crocks/helpers/pipe.js
var require_pipe = __commonJS({
  "node_modules/crocks/helpers/pipe.js"(exports, module) {
    var isFunction = require_isFunction();
    var err = "pipe: Functions required";
    function applyPipe(f, g) {
      if (!isFunction(g)) {
        throw new TypeError(err);
      }
      return function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        return g.call(null, f.apply(null, args));
      };
    }
    function pipe() {
      var fns = [], len = arguments.length;
      while (len--)
        fns[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var head = fns[0];
      if (!isFunction(head)) {
        throw new TypeError(err);
      }
      var tail = fns.slice(1).concat(function(x) {
        return x;
      });
      return tail.reduce(applyPipe, head);
    }
    module.exports = pipe;
  }
});

// node_modules/crocks/helpers/pipeK.js
var require_pipeK = __commonJS({
  "node_modules/crocks/helpers/pipeK.js"(exports, module) {
    var isChain = require_isChain();
    var isFunction = require_isFunction();
    var err = "pipeK: Chain returning functions of the same type required";
    function pipeK(head) {
      var fns = [], len = arguments.length - 1;
      while (len-- > 0)
        fns[len] = arguments[len + 1];
      if (!(arguments.length && isFunction(head))) {
        throw new TypeError(err);
      }
      if (arguments.length === 1) {
        return head;
      }
      var tail = fns.reduce(function(comp, fn) {
        if (!isFunction(fn)) {
          throw new TypeError(err);
        }
        return function(m) {
          if (!isChain(m)) {
            throw new TypeError(err);
          }
          return comp(m).chain(fn);
        };
      }, function(x) {
        return x;
      });
      return function() {
        return tail(head.apply(null, arguments));
      };
    }
    module.exports = pipeK;
  }
});

// node_modules/crocks/helpers/pipeP.js
var require_pipeP = __commonJS({
  "node_modules/crocks/helpers/pipeP.js"(exports, module) {
    var isFunction = require_isFunction();
    var isPromise = require_isPromise();
    var err = "pipeP: Promise returning functions required";
    function applyPipe(f, g) {
      if (!isFunction(g)) {
        throw new TypeError(err);
      }
      return function() {
        var p = f.apply(null, arguments);
        if (!isPromise(p)) {
          throw new TypeError(err);
        }
        return p.then(g);
      };
    }
    function pipeP() {
      var fns = [], len = arguments.length;
      while (len--)
        fns[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var head = fns[0];
      if (!isFunction(head)) {
        throw new TypeError(err);
      }
      var tail = fns.slice(1).concat(function(x) {
        return x;
      });
      return tail.reduce(applyPipe, head);
    }
    module.exports = pipeP;
  }
});

// node_modules/crocks/helpers/pipeS.js
var require_pipeS = __commonJS({
  "node_modules/crocks/helpers/pipeS.js"(exports, module) {
    var isSameType = require_isSameType();
    var isSemigroupoid = require_isSemigroupoid();
    var err = "pipeS: Semigroupoids of the same type required";
    function pipeS() {
      var ms = [], len = arguments.length;
      while (len--)
        ms[len] = arguments[len];
      if (!arguments.length) {
        throw new TypeError(err);
      }
      var head = ms[0];
      if (!isSemigroupoid(head)) {
        throw new TypeError(err);
      }
      if (ms.length === 1) {
        return head;
      }
      return ms.slice().reduce(function(comp, m) {
        if (!isSameType(comp, m)) {
          throw new TypeError(err);
        }
        return comp.compose(m);
      });
    }
    module.exports = pipeS;
  }
});

// node_modules/crocks/helpers/propOr.js
var require_propOr = __commonJS({
  "node_modules/crocks/helpers/propOr.js"(exports, module) {
    var getPropOr = require_getPropOr();
    module.exports = getPropOr.origFn("propOr");
  }
});

// node_modules/crocks/helpers/propPathOr.js
var require_propPathOr = __commonJS({
  "node_modules/crocks/helpers/propPathOr.js"(exports, module) {
    var getPathOr = require_getPathOr();
    module.exports = getPathOr.origFn("propPathOr");
  }
});

// node_modules/crocks/helpers/setPath.js
var require_setPath = __commonJS({
  "node_modules/crocks/helpers/setPath.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isObject = require_isObject();
    var isString = require_isString();
    var object = require_object();
    var isValid = function(x) {
      return isObject(x) || isArray(x);
    };
    var pathErr = "setPath: Non-empty Array of non-empty Strings and/or Positive Integers required for first argument";
    function setPath(path, val, obj) {
      if (!isArray(path) || isEmpty(path)) {
        throw new TypeError(pathErr);
      }
      if (!isValid(obj)) {
        throw new TypeError(
          "setPath: Object or Array required for third argument"
        );
      }
      var key = path[0];
      var newVal = val;
      if (!(isString(key) && !isEmpty(key) || isInteger(key) && key >= 0)) {
        throw new TypeError(pathErr);
      }
      if (path.length > 1) {
        var next = !isValid(obj[key]) ? isInteger(path[1]) ? [] : {} : obj[key];
        newVal = setPath(path.slice(1), val, next);
      }
      if (isObject(obj)) {
        if (isString(key)) {
          return object.set(key, newVal, obj);
        }
        throw new TypeError(
          "setPath: Non-empty String required in path when referencing an Object"
        );
      }
      if (isInteger(key)) {
        return array.set(key, newVal, obj);
      }
      throw new TypeError(
        "setPath: Positive Integers required in path when referencing an Array"
      );
    }
    module.exports = curry(setPath);
  }
});

// node_modules/crocks/helpers/tap.js
var require_tap = __commonJS({
  "node_modules/crocks/helpers/tap.js"(exports, module) {
    var curry = require_curry();
    var compose = require_compose();
    var isFunction = require_isFunction();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    function tap(fn, x) {
      if (!isFunction(fn)) {
        throw new TypeError(
          "tap: Function required for first argument"
        );
      }
      return compose(constant(x), fn)(x);
    }
    module.exports = curry(tap);
  }
});

// node_modules/crocks/helpers/unary.js
var require_unary = __commonJS({
  "node_modules/crocks/helpers/unary.js"(exports, module) {
    var isFunction = require_isFunction();
    function unary(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("unary: Function required");
      }
      return function(x) {
        return fn(x);
      };
    }
    module.exports = unary;
  }
});

// node_modules/crocks/helpers/unit.js
var require_unit2 = __commonJS({
  "node_modules/crocks/helpers/unit.js"(exports, module) {
    module.exports = require_unit();
  }
});

// node_modules/crocks/helpers/unsetPath.js
var require_unsetPath = __commonJS({
  "node_modules/crocks/helpers/unsetPath.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isObject = require_isObject();
    var isString = require_isString();
    var array = require_array();
    var object = require_object();
    var pathError = "unsetPath: Non-empty Array of non-empty Strings and/or Positive Integers required for first argument";
    function unsetPath(path, obj) {
      if (!isArray(path) || isEmpty(path)) {
        throw new TypeError(pathError);
      }
      if (!(isObject(obj) || isArray(obj))) {
        return obj;
      }
      var key = path[0];
      if (!(isString(key) && !isEmpty(key) || isInteger(key) && key >= 0)) {
        throw new TypeError(pathError);
      }
      if (path.length === 1) {
        if (isArray(obj) && isInteger(key)) {
          return array.unset(key, obj);
        }
        if (isObject(obj) && isString(key)) {
          return object.unset(key, obj);
        }
        return obj;
      }
      var next = obj[key];
      if (!(isObject(next) || isArray(next))) {
        return obj;
      }
      if (isArray(obj)) {
        return array.set(key, unsetPath(path.slice(1), next), obj);
      }
      return object.set(key, unsetPath(path.slice(1), next), obj);
    }
    module.exports = curry(unsetPath);
  }
});

// node_modules/crocks/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/crocks/helpers/index.js"(exports, module) {
    module.exports = {
      assign: require_assign(),
      assoc: require_assoc(),
      binary: require_binary(),
      compose: require_compose3(),
      composeK: require_composeK(),
      composeP: require_composeP(),
      composeS: require_composeS(),
      curry: require_curry2(),
      defaultProps: require_defaultProps(),
      defaultTo: require_defaultTo(),
      dissoc: require_dissoc(),
      fromPairs: require_fromPairs(),
      getPathOr: require_getPathOr(),
      liftA2: require_liftA2(),
      liftA3: require_liftA3(),
      liftN: require_liftN(),
      getPropOr: require_getPropOr(),
      mapProps: require_mapProps(),
      mapReduce: require_mapReduce(),
      mconcat: require_mconcat(),
      mconcatMap: require_mconcatMap2(),
      mreduce: require_mreduce(),
      mreduceMap: require_mreduceMap(),
      nAry: require_nAry(),
      objOf: require_objOf(),
      omit: require_omit(),
      once: require_once2(),
      partial: require_partial(),
      pick: require_pick(),
      pipe: require_pipe(),
      pipeK: require_pipeK(),
      pipeP: require_pipeP(),
      pipeS: require_pipeS(),
      propOr: require_propOr(),
      propPathOr: require_propPathOr(),
      setPath: require_setPath(),
      setProp: require_setProp(),
      tap: require_tap(),
      unary: require_unary(),
      unit: require_unit2(),
      unsetPath: require_unsetPath(),
      unsetProp: require_unsetProp()
    };
  }
});

// node_modules/crocks/Pair/branch.js
var require_branch = __commonJS({
  "node_modules/crocks/Pair/branch.js"(exports, module) {
    var Pair = require_Pair();
    function branch(x) {
      return Pair(x, x);
    }
    module.exports = branch;
  }
});

// node_modules/crocks/Pair/fanout.js
var require_fanout = __commonJS({
  "node_modules/crocks/Pair/fanout.js"(exports, module) {
    var Pair = require_Pair();
    var curry = require_curry();
    var isContravariant = require_isContravariant();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var isSemigroupoid = require_isSemigroupoid();
    var valid = function(x, y) {
      return isSameType(x, y) && isSemigroupoid(x) && isContravariant(x) && isFunction(x.first) && isFunction(x.second);
    };
    function fanout(fst, snd) {
      if (isFunction(fst) && isFunction(snd)) {
        return function(x) {
          return Pair(fst(x), snd(x));
        };
      }
      if (valid(fst, snd)) {
        return fst.first().compose(snd.second()).contramap(function(x) {
          return Pair(x, x);
        });
      }
      throw new TypeError(
        "fanout: Arrows, Functions or Stars of the same type required for both arguments"
      );
    }
    module.exports = curry(fanout);
  }
});

// node_modules/crocks/Maybe/find.js
var require_find = __commonJS({
  "node_modules/crocks/Maybe/find.js"(exports, module) {
    var Pred = require_types().proxy("Pred");
    var curry = require_curry();
    var predOrFunc = require_predOrFunc();
    var isFunction = require_isFunction();
    var isFoldable = require_isFoldable();
    var isSameType = require_isSameType();
    var ref = require_Maybe2();
    var Just = ref.Just;
    var Nothing = ref.Nothing;
    var accumulator = function(fn) {
      return function(acc, cur) {
        return !acc.found && predOrFunc(fn, cur) ? { found: true, value: cur } : acc;
      };
    };
    function find(fn, foldable) {
      if (!isFunction(fn) && !isSameType(Pred, fn)) {
        throw new TypeError("find: First argument must be a Pred or predicate");
      }
      if (!isFoldable(foldable)) {
        throw new TypeError("find: Second argument must be a Foldable");
      }
      var result = foldable.reduce(accumulator(fn), { found: false });
      return result.found ? Just(result.value) : Nothing();
    }
    module.exports = curry(find);
  }
});

// node_modules/crocks/Maybe/getPath.js
var require_getPath = __commonJS({
  "node_modules/crocks/Maybe/getPath.js"(exports, module) {
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    var curry = require_curry();
    var isArray = require_isArray();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isInteger = require_isInteger();
    var isNil = require_isNil();
    var isString = require_isString();
    function fn(name) {
      function getPath2(keys, target) {
        if (!isArray(keys)) {
          throw new TypeError(name + ": Array of Non-empty Strings or Integers required for first argument");
        }
        if (isNil(target)) {
          return Nothing();
        }
        var value = target;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
            throw new TypeError(name + ": Array of Non-empty Strings or Integers required for first argument");
          }
          if (isNil(value)) {
            return Nothing();
          }
          value = value[key];
          if (!isDefined(value)) {
            return Nothing();
          }
        }
        return Just(value);
      }
      return curry(getPath2);
    }
    var getPath = fn("getPath");
    getPath.origFn = fn;
    module.exports = getPath;
  }
});

// node_modules/crocks/Maybe/getProp.js
var require_getProp = __commonJS({
  "node_modules/crocks/Maybe/getProp.js"(exports, module) {
    var curry = require_curry();
    var isDefined = require_isDefined();
    var isEmpty = require_isEmpty();
    var isNil = require_isNil();
    var isInteger = require_isInteger();
    var isString = require_isString();
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    function fn(name) {
      function getProp2(key, target) {
        if (!(isString(key) && !isEmpty(key) || isInteger(key))) {
          throw new TypeError(name + ": Non-empty String or Integer required for first argument");
        }
        if (isNil(target)) {
          return Nothing();
        }
        var value = target[key];
        return isDefined(value) ? Just(value) : Nothing();
      }
      return curry(getProp2);
    }
    var getProp = fn("getProp");
    getProp.origFn = fn;
    module.exports = getProp;
  }
});

// node_modules/crocks/Maybe/prop.js
var require_prop = __commonJS({
  "node_modules/crocks/Maybe/prop.js"(exports, module) {
    var getProp = require_getProp();
    module.exports = getProp.origFn("prop");
  }
});

// node_modules/crocks/Maybe/propPath.js
var require_propPath = __commonJS({
  "node_modules/crocks/Maybe/propPath.js"(exports, module) {
    var getPath = require_getPath();
    module.exports = getPath.origFn("propPath");
  }
});

// node_modules/crocks/Maybe/safe.js
var require_safe = __commonJS({
  "node_modules/crocks/Maybe/safe.js"(exports, module) {
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    var predOrFunc = require_predOrFunc();
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    function safe(pred, x) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError("safe: Pred or predicate function required for first argument");
      }
      return predOrFunc(pred, x) ? Just(x) : Nothing();
    }
    module.exports = curry(safe);
  }
});

// node_modules/crocks/Maybe/safeAfter.js
var require_safeAfter = __commonJS({
  "node_modules/crocks/Maybe/safeAfter.js"(exports, module) {
    var ref = require_Maybe();
    var Just = ref.Just;
    var Nothing = ref.Nothing;
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var isFunction = require_isFunction();
    var predOrFunc = require_predOrFunc();
    function safeAfter(pred, fn) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError("safeAfter: Pred or predicate function required for first argument");
      }
      if (!isFunction(fn)) {
        throw new TypeError("safeAfter: Function required for second argument");
      }
      return function(x) {
        var result = fn(x);
        return predOrFunc(pred, result) ? Just(result) : Nothing();
      };
    }
    module.exports = curry(safeAfter);
  }
});

// node_modules/crocks/Maybe/safeLift.js
var require_safeLift = __commonJS({
  "node_modules/crocks/Maybe/safeLift.js"(exports, module) {
    var compose = require_compose();
    var curry = require_curry();
    var isPredOrFunc = require_isPredOrFunc();
    var isFunction = require_isFunction();
    var safe = require_safe();
    var map = function(fn) {
      return function(m) {
        return m.map(fn);
      };
    };
    function safeLift(pred, fn) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError("safeLift: Pred or predicate function required for first argument");
      } else if (!isFunction(fn)) {
        throw new TypeError("safeLift: Function required for second argument");
      }
      return compose(map(fn), safe(pred));
    }
    module.exports = curry(safeLift);
  }
});

// node_modules/crocks/Pair/toPairs.js
var require_toPairs = __commonJS({
  "node_modules/crocks/Pair/toPairs.js"(exports, module) {
    var List = require_List();
    var Pair = require_Pair();
    var isObject = require_isObject();
    function toPairs(obj) {
      if (!isObject(obj)) {
        throw new TypeError("toPairs: Object required for argument");
      }
      return Object.keys(obj).reduce(
        function(acc, key) {
          return obj[key] !== void 0 ? acc.concat(List.of(Pair(key, obj[key]))) : acc;
        },
        List.empty()
      );
    }
    module.exports = toPairs;
  }
});

// node_modules/crocks/Result/tryCatch.js
var require_tryCatch = __commonJS({
  "node_modules/crocks/Result/tryCatch.js"(exports, module) {
    var ref = require_Result();
    var Err = ref.Err;
    var Ok = ref.Ok;
    var curry = require_curry();
    var isFunction = require_isFunction();
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError("tryCatch: Function required for first argument");
      }
      var safe = function() {
        try {
          return Ok(fn.apply(this, arguments));
        } catch (e) {
          return Err(e);
        }
      };
      Object.defineProperty(safe, "length", { value: fn.length });
      return safe;
    }
    module.exports = curry(tryCatch);
  }
});

// node_modules/crocks/All/index.js
var require_All = __commonJS({
  "node_modules/crocks/All/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("All");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    var isSameType = require_isSameType();
    var _empty = function() {
      return All(true);
    };
    function All(b) {
      var obj;
      var x = isNil(b) ? _empty().valueOf() : b;
      if (!arguments.length || isFunction(x)) {
        throw new TypeError("All: Non-function value required");
      }
      var valueOf = function() {
        return !!x;
      };
      var empty = _empty;
      var equals = function(m) {
        return isSameType(All, m) && _equals(x, m.valueOf());
      };
      var inspect = function() {
        return "All" + _inspect(valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(All, m)) {
            throw new TypeError("All." + method + ": All required");
          }
          return All(m.valueOf() && valueOf());
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty
      }, obj["@@type"] = _type, obj.concat = concat("concat"), obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.empty] = empty, obj.constructor = All, obj;
    }
    All["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    All.empty = _empty;
    All.type = type;
    All[fl.empty] = _empty;
    All["@@type"] = _type;
    module.exports = All;
  }
});

// node_modules/crocks/Any/index.js
var require_Any = __commonJS({
  "node_modules/crocks/Any/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Any");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Any(false);
    };
    function Any(b) {
      var obj;
      var x = isNil(b) ? _empty().valueOf() : b;
      if (!arguments.length || isFunction(x)) {
        throw new TypeError("Any: Non-function value required");
      }
      var valueOf = function() {
        return !!x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Any" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Any, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Any, m)) {
            throw new TypeError("Any." + method + ": Any required");
          }
          return Any(m.valueOf() || valueOf());
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty
      }, obj["@@type"] = _type, obj.concat = concat("concat"), obj[fl.equals] = equals, obj[fl.concat] = concat(fl.concat), obj[fl.empty] = empty, obj.constructor = Any, obj;
    }
    Any["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Any.empty = _empty;
    Any.type = type;
    Any[fl.empty] = _empty;
    Any["@@type"] = _type;
    module.exports = Any;
  }
});

// node_modules/crocks/Assign/index.js
var require_Assign = __commonJS({
  "node_modules/crocks/Assign/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _object = require_object();
    var _equals = require_equals();
    var type = require_types().type("Assign");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isNil = require_isNil();
    var isObject = require_isObject();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Assign({});
    };
    function Assign(o) {
      var obj;
      var x = isNil(o) ? _empty().valueOf() : o;
      if (!arguments.length || !isObject(x)) {
        throw new TypeError("Assign: Object required");
      }
      var valueOf = function() {
        return x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Assign" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Assign, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Assign, m)) {
            throw new TypeError("Assign." + method + ": Assign required");
          }
          return Assign(_object.assign(m.valueOf(), x));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Assign, obj;
    }
    Assign["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Assign.empty = _empty;
    Assign.type = type;
    Assign[fl.empty] = _empty;
    Assign["@@type"] = _type;
    module.exports = Assign;
  }
});

// node_modules/crocks/Endo/index.js
var require_Endo = __commonJS({
  "node_modules/crocks/Endo/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var type = require_types().type("Endo");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var compose = require_compose();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Endo(function(x) {
        return x;
      });
    };
    function Endo(runWith) {
      var obj;
      if (!isFunction(runWith)) {
        throw new TypeError("Endo: Function value required");
      }
      var valueOf = function() {
        return runWith;
      };
      var empty = _empty;
      var inspect = function() {
        return "Endo" + _inspect(valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Endo, m)) {
            throw new TypeError("Endo." + method + ": Endo required");
          }
          return Endo(compose(m.valueOf(), valueOf()));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        valueOf,
        type,
        empty,
        runWith,
        concat: concat("concat")
      }, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Endo, obj;
    }
    Endo["@@implements"] = _implements(
      ["concat", "empty"]
    );
    Endo.empty = _empty;
    Endo.type = type;
    Endo[fl.empty] = _empty;
    Endo["@@type"] = _type;
    module.exports = Endo;
  }
});

// node_modules/crocks/First/index.js
var require_First = __commonJS({
  "node_modules/crocks/First/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("First");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isSameType = require_isSameType();
    var Maybe = require_Maybe();
    var _empty = function() {
      return First(Maybe.Nothing());
    };
    function First(x) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("First: Requires one argument");
      }
      var maybe = !isSameType(Maybe, x) ? Maybe.of(x) : x.map(function(x2) {
        return x2;
      });
      var empty = _empty;
      var inspect = function() {
        return "First(" + _inspect(maybe) + " )";
      };
      var equals = function(m) {
        return isSameType(First, m) && _equals(maybe, m.valueOf());
      };
      var valueOf = function() {
        return maybe;
      };
      var option = maybe.option;
      function concat(method) {
        return function(m) {
          if (!isSameType(First, m)) {
            throw new TypeError("First." + method + ": First required");
          }
          var n = m.valueOf().map(function(x2) {
            return x2;
          });
          return First(
            maybe.either(function() {
              return n;
            }, Maybe.Just)
          );
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        empty,
        option,
        type,
        valueOf,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = _empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = First, obj;
    }
    First["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    First.empty = _empty;
    First.type = type;
    First[fl.empty] = _empty;
    First["@@type"] = _type;
    module.exports = First;
  }
});

// node_modules/crocks/Last/index.js
var require_Last = __commonJS({
  "node_modules/crocks/Last/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Last");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isSameType = require_isSameType();
    var Maybe = require_Maybe();
    var _empty = function() {
      return Last(Maybe.Nothing());
    };
    function Last(x) {
      var obj;
      if (!arguments.length) {
        throw new TypeError("Last: Requires one argument");
      }
      var maybe = !isSameType(Maybe, x) ? Maybe.of(x) : x.map(function(x2) {
        return x2;
      });
      var valueOf = function() {
        return maybe;
      };
      var empty = _empty;
      var inspect = function() {
        return "Last(" + _inspect(maybe) + " )";
      };
      var equals = function(m) {
        return isSameType(Last, m) && _equals(maybe, m.valueOf());
      };
      var option = maybe.option;
      function concat(method) {
        return function(m) {
          if (!isSameType(Last, m)) {
            throw new TypeError("Last." + method + ": Last required");
          }
          var n = m.valueOf().map(function(x2) {
            return x2;
          });
          return Last(
            maybe.either(
              function() {
                return n;
              },
              function() {
                return n.either(function() {
                  return maybe;
                }, function() {
                  return n;
                });
              }
            )
          );
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        empty,
        option,
        type,
        valueOf,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Last, obj;
    }
    Last["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Last.empty = _empty;
    Last.type = type;
    Last[fl.empty] = _empty;
    Last["@@type"] = _type;
    module.exports = Last;
  }
});

// node_modules/crocks/Max/index.js
var require_Max = __commonJS({
  "node_modules/crocks/Max/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Max");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isNil = require_isNil();
    var isNumber = require_isNumber();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Max(-Infinity);
    };
    function Max(n) {
      var obj;
      var x = isNil(n) ? _empty().valueOf() : n;
      if (!arguments.length || !isNumber(x)) {
        throw new TypeError("Max: Numeric value required");
      }
      var valueOf = function() {
        return x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Max" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Max, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Max, m)) {
            throw new TypeError("Max." + method + ": Max requried");
          }
          return Max(Math.max(x, m.valueOf()));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Max, obj;
    }
    Max["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Max.empty = _empty;
    Max.type = type;
    Max[fl.empty] = _empty;
    Max["@@type"] = _type;
    module.exports = Max;
  }
});

// node_modules/crocks/Min/index.js
var require_Min = __commonJS({
  "node_modules/crocks/Min/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Min");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isNil = require_isNil();
    var isNumber = require_isNumber();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Min(Infinity);
    };
    function Min(n) {
      var obj;
      var x = isNil(n) ? _empty().valueOf() : n;
      if (!arguments.length || !isNumber(x)) {
        throw new TypeError("Min: Numeric value required");
      }
      var valueOf = function() {
        return x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Min" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Min, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Min, m)) {
            throw new TypeError("Min." + method + ": Min required");
          }
          return Min(Math.min(x, m.valueOf()));
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Min, obj;
    }
    Min["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Min.empty = _empty;
    Min.type = type;
    Min[fl.empty] = _empty;
    Min["@@type"] = _type;
    module.exports = Min;
  }
});

// node_modules/crocks/Prod/index.js
var require_Prod = __commonJS({
  "node_modules/crocks/Prod/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Prod");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isNil = require_isNil();
    var isNumber = require_isNumber();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Prod(1);
    };
    function Prod(n) {
      var obj;
      var x = isNil(n) ? _empty().valueOf() : n;
      if (!arguments.length || !isNumber(x)) {
        throw new TypeError("Prod: Numeric value required");
      }
      var valueOf = function() {
        return x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Prod" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Prod, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Prod, m)) {
            throw new TypeError("Prod." + method + ": Prod required");
          }
          return Prod(x * m.valueOf());
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        equals,
        valueOf,
        type,
        empty,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Prod, obj;
    }
    Prod["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Prod.empty = _empty;
    Prod.type = type;
    Prod[fl.empty] = _empty;
    Prod["@@type"] = _type;
    module.exports = Prod;
  }
});

// node_modules/crocks/Sum/index.js
var require_Sum = __commonJS({
  "node_modules/crocks/Sum/index.js"(exports, module) {
    var VERSION = 2;
    var _implements = require_implements();
    var _inspect = require_inspect();
    var _equals = require_equals();
    var type = require_types().type("Sum");
    var _type = require_types().typeFn(type(), VERSION);
    var fl = require_flNames();
    var isNil = require_isNil();
    var isNumber = require_isNumber();
    var isSameType = require_isSameType();
    var _empty = function() {
      return Sum(0);
    };
    function Sum(n) {
      var obj;
      var x = isNil(n) ? _empty().valueOf() : n;
      if (!arguments.length || !isNumber(x)) {
        throw new TypeError("Sum: Numeric value required");
      }
      var valueOf = function() {
        return x;
      };
      var empty = _empty;
      var inspect = function() {
        return "Sum" + _inspect(valueOf());
      };
      var equals = function(m) {
        return isSameType(Sum, m) && _equals(x, m.valueOf());
      };
      function concat(method) {
        return function(m) {
          if (!isSameType(Sum, m)) {
            throw new TypeError("Sum." + method + ": Sum required");
          }
          return Sum(x + m.valueOf());
        };
      }
      return obj = {
        inspect,
        toString: inspect,
        valueOf,
        equals,
        type,
        empty,
        concat: concat("concat")
      }, obj[fl.equals] = equals, obj[fl.empty] = empty, obj[fl.concat] = concat(fl.concat), obj["@@type"] = _type, obj.constructor = Sum, obj;
    }
    Sum["@@implements"] = _implements(
      ["equals", "concat", "empty"]
    );
    Sum.empty = _empty;
    Sum.type = type;
    Sum[fl.empty] = _empty;
    Sum["@@type"] = _type;
    module.exports = Sum;
  }
});

// node_modules/crocks/pointfree/alt.js
var require_alt = __commonJS({
  "node_modules/crocks/pointfree/alt.js"(exports, module) {
    var curry = require_curry();
    var fl = require_flNames();
    var isAlt = require_isAlt();
    var isSameType = require_isSameType();
    function alt(m, x) {
      if (!(isAlt(m) && isSameType(m, x))) {
        throw new TypeError(
          "alt: Both arguments must be Alts of the same type"
        );
      }
      return (x[fl.alt] || x.alt).call(x, m);
    }
    module.exports = curry(alt);
  }
});

// node_modules/crocks/pointfree/ap.js
var require_ap = __commonJS({
  "node_modules/crocks/pointfree/ap.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isApplicative = require_isApplicative();
    var isArray = require_isArray();
    var isSameType = require_isSameType();
    function ap(m, x) {
      if (!((isApplicative(m) || isArray(m)) && isSameType(m, x))) {
        throw new TypeError("ap: Both arguments must be Applys of the same type");
      }
      if (isArray(x)) {
        return array.ap(m, x);
      }
      return x.ap(m);
    }
    module.exports = curry(ap);
  }
});

// node_modules/crocks/pointfree/bimap.js
var require_bimap = __commonJS({
  "node_modules/crocks/pointfree/bimap.js"(exports, module) {
    var curry = require_curry();
    var isBifunctor = require_isBifunctor();
    var isFunction = require_isFunction();
    var fl = require_flNames();
    function bimap(f, g, m) {
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "bimap: Functions required for first two arguments"
        );
      }
      if (!isBifunctor(m)) {
        throw new TypeError(
          "bimap: Bifunctor required for third argument"
        );
      }
      return (m[fl.bimap] || m.bimap).call(m, f, g);
    }
    module.exports = curry(bimap);
  }
});

// node_modules/crocks/pointfree/bichain.js
var require_bichain = __commonJS({
  "node_modules/crocks/pointfree/bichain.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function bichain(f, g, m) {
      if (!isFunction(f) || !isFunction(g)) {
        throw new TypeError("bichain: First two arguments must be Sum Type returning functions");
      }
      if (m && isFunction(m.bichain)) {
        return m.bichain.call(m, f, g);
      }
      throw new TypeError(
        "bichain: Third argument must be a Sum Type"
      );
    }
    module.exports = curry(bichain);
  }
});

// node_modules/crocks/pointfree/both.js
var require_both = __commonJS({
  "node_modules/crocks/pointfree/both.js"(exports, module) {
    var Pair = require_types().proxy("Pair");
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    function both(m) {
      if (isFunction(m)) {
        return function(x) {
          if (!isSameType(Pair, x)) {
            throw new TypeError("both: Pair required as input");
          }
          return x.bimap(m, m);
        };
      }
      if (m && isFunction(m.both)) {
        return m.both();
      }
      throw new TypeError("both: Strong Function or Profunctor required");
    }
    module.exports = both;
  }
});

// node_modules/crocks/pointfree/chain.js
var require_chain = __commonJS({
  "node_modules/crocks/pointfree/chain.js"(exports, module) {
    var _chain = require_array().chain;
    var curry = require_curry();
    var isArray = require_isArray();
    var isChain = require_isChain();
    var isFunction = require_isFunction();
    var fl = require_flNames();
    function chain(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError("chain: Chain returning function required for first argument");
      }
      if (!(isChain(m) || isArray(m))) {
        throw new TypeError("chain: Chain of the same type required for second argument");
      }
      if (isArray(m)) {
        return _chain(fn, m);
      }
      return (m[fl.chain] || m.chain).call(m, fn);
    }
    module.exports = curry(chain);
  }
});

// node_modules/crocks/pointfree/coalesce.js
var require_coalesce = __commonJS({
  "node_modules/crocks/pointfree/coalesce.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function coalesce(f, g, m) {
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "coalesce: Functions required for first two arguments"
        );
      }
      if (m && isFunction(m.coalesce)) {
        return m.coalesce(f, g);
      }
      throw new TypeError(
        "coalesce: Sum Type required for third argument"
      );
    }
    module.exports = curry(coalesce);
  }
});

// node_modules/crocks/pointfree/compareWith.js
var require_compareWith = __commonJS({
  "node_modules/crocks/pointfree/compareWith.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function compareWith(x, y, m) {
      if (!(m && isFunction(m.compareWith))) {
        throw new TypeError("compareWith: Equiv required for third argument");
      }
      return m.compareWith(x, y);
    }
    module.exports = curry(compareWith);
  }
});

// node_modules/crocks/pointfree/concat.js
var require_concat = __commonJS({
  "node_modules/crocks/pointfree/concat.js"(exports, module) {
    var curry = require_curry();
    var isSameType = require_isSameType();
    var isSemigroup = require_isSemigroup();
    var fl = require_flNames();
    function concat(x, m) {
      if (!(isSemigroup(m) && isSameType(x, m))) {
        throw new TypeError(
          "concat: Semigroups of the same type required for both arguments"
        );
      }
      return (m[fl.concat] || m.concat).call(m, x);
    }
    module.exports = curry(concat);
  }
});

// node_modules/crocks/pointfree/cons.js
var require_cons = __commonJS({
  "node_modules/crocks/pointfree/cons.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    function cons(x, m) {
      if (m && isFunction(m.cons)) {
        return m.cons(x);
      } else if (isArray(m)) {
        return [x].concat(m);
      }
      throw new TypeError("cons: List or Array required for second argument");
    }
    module.exports = curry(cons);
  }
});

// node_modules/crocks/pointfree/contramap.js
var require_contramap = __commonJS({
  "node_modules/crocks/pointfree/contramap.js"(exports, module) {
    var compose = require_compose();
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isContravariant = require_isContravariant();
    var fl = require_flNames();
    function contramap(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError(
          "contramap: Function required for first argument"
        );
      }
      if (isFunction(m)) {
        return compose(m, fn);
      }
      if (isContravariant(m)) {
        return (m[fl.contramap] || m.contramap).call(m, fn);
      }
      throw new TypeError(
        "contramap: Function or Contavariant Functor of the same type required for second argument"
      );
    }
    module.exports = curry(contramap);
  }
});

// node_modules/crocks/pointfree/either.js
var require_either = __commonJS({
  "node_modules/crocks/pointfree/either.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function either(lf, rf, m) {
      if (!(isFunction(lf) && isFunction(rf))) {
        throw new TypeError(
          "either: First two arguments must be functions"
        );
      }
      if (!(m && isFunction(m.either))) {
        throw new TypeError(
          "either: Last argument must be a Sum Type"
        );
      }
      return m.either(lf, rf);
    }
    module.exports = curry(either);
  }
});

// node_modules/crocks/pointfree/empty.js
var require_empty = __commonJS({
  "node_modules/crocks/pointfree/empty.js"(exports, module) {
    var hasAlg = require_hasAlg();
    var isSameType = require_isSameType();
    var fl = require_flNames();
    function empty(m) {
      if (m && hasAlg("empty", m)) {
        return (m[fl.empty] || m.empty).call(m);
      }
      if (m && hasAlg("empty", m.constructor)) {
        return (m.constructor[fl.empty] || m.constructor.empty).call(m);
      }
      if (isSameType([], m)) {
        return [];
      }
      if (isSameType("", m)) {
        return "";
      }
      if (isSameType({}, m)) {
        return {};
      }
      throw new TypeError("empty: Monoid, Array, String or Object required");
    }
    module.exports = empty;
  }
});

// node_modules/crocks/pointfree/equals.js
var require_equals2 = __commonJS({
  "node_modules/crocks/pointfree/equals.js"(exports, module) {
    var _equals = require_equals();
    var curry = require_curry();
    function equals(x, y) {
      return _equals(x, y);
    }
    module.exports = curry(equals);
  }
});

// node_modules/crocks/pointfree/extend.js
var require_extend = __commonJS({
  "node_modules/crocks/pointfree/extend.js"(exports, module) {
    var curry = require_curry();
    var fl = require_flNames();
    var isExtend = require_isExtend();
    var isFunction = require_isFunction();
    function extend(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError("extend: Function required for first argument");
      }
      if (!isExtend(m)) {
        throw new TypeError("extend: Extend required for second argument");
      }
      return (m[fl.extend] || m.extend).call(m, fn);
    }
    module.exports = curry(extend);
  }
});

// node_modules/crocks/pointfree/filter.js
var require_filter = __commonJS({
  "node_modules/crocks/pointfree/filter.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isPredOrFunc = require_isPredOrFunc();
    var isObject = require_isObject();
    var object = require_object();
    var predOrFunc = require_predOrFunc();
    function filter(pred, m) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError("filter: Pred or predicate function required for first argument");
      }
      var fn = function(x) {
        return predOrFunc(pred, x);
      };
      if (m && isFunction(m.filter)) {
        return m.filter(fn);
      }
      if (m && isObject(m)) {
        return object.filter(fn, m);
      }
      throw new TypeError("filter: Filterable or Object required for second argument");
    }
    module.exports = curry(filter);
  }
});

// node_modules/crocks/pointfree/first.js
var require_first = __commonJS({
  "node_modules/crocks/pointfree/first.js"(exports, module) {
    var Pair = require_types().proxy("Pair");
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var identity = function(x) {
      return x;
    };
    function first(m) {
      if (isFunction(m)) {
        return function(x) {
          if (!isSameType(Pair, x)) {
            throw new TypeError("first: Pair required as input");
          }
          return x.bimap(m, identity);
        };
      }
      if (m && isFunction(m.first)) {
        return m.first();
      }
      throw new TypeError("first: Arrow, Function or Star required");
    }
    module.exports = first;
  }
});

// node_modules/crocks/pointfree/fold.js
var require_fold = __commonJS({
  "node_modules/crocks/pointfree/fold.js"(exports, module) {
    var _array = require_array();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    function fold(m) {
      if (isArray(m)) {
        return _array.fold(m);
      }
      if (m && isFunction(m.fold)) {
        return m.fold();
      }
      throw new TypeError("fold: Non-empty Foldable with at least one Semigroup is required");
    }
    module.exports = fold;
  }
});

// node_modules/crocks/pointfree/foldMap.js
var require_foldMap = __commonJS({
  "node_modules/crocks/pointfree/foldMap.js"(exports, module) {
    var _array = require_array();
    var curry = require_curry();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    function foldMap(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError(
          "foldMap: Function returning Semigroups of the same type required for first argument"
        );
      }
      if (isArray(m)) {
        return _array.foldMap(fn, m);
      }
      if (m && isFunction(m.foldMap)) {
        return m.foldMap(fn);
      }
      throw new TypeError(
        "foldMap: Non-empty Foldable with at least one Semigroup required for second argument"
      );
    }
    module.exports = curry(foldMap);
  }
});

// node_modules/crocks/core/cloneIterable.js
var require_cloneIterable = __commonJS({
  "node_modules/crocks/core/cloneIterable.js"(exports, module) {
    function cloneIterable(source) {
      var copy = Object.create(Object.getPrototypeOf(source));
      Object.assign(copy, source);
      var symbols = Object.getOwnPropertySymbols(source);
      symbols.forEach(function(symbol) {
        copy[symbol] = source[symbol];
      });
      return copy;
    }
    module.exports = cloneIterable;
  }
});

// node_modules/crocks/pointfree/head.js
var require_head = __commonJS({
  "node_modules/crocks/pointfree/head.js"(exports, module) {
    var cloneIterable = require_cloneIterable();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isIterable = require_isIterable();
    var isString = require_isString();
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    function head(m) {
      if (m && isFunction(m.head)) {
        return m.head();
      }
      if (isArray(m) || isString(m)) {
        return !m.length ? Nothing() : Just(m[0]);
      }
      if (isIterable(m)) {
        var cloned = cloneIterable(m);
        var iterator = cloned[Symbol.iterator]();
        var head2 = iterator.next();
        return head2.done ? Nothing() : Just(head2.value);
      }
      throw new TypeError("head: List or iterable required");
    }
    module.exports = head;
  }
});

// node_modules/crocks/pointfree/init.js
var require_init = __commonJS({
  "node_modules/crocks/pointfree/init.js"(exports, module) {
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    function init(m) {
      if (!isNil(m)) {
        if (isFunction(m.init)) {
          return m.init();
        }
        if (isFunction(m.slice)) {
          return m.length < 2 ? Nothing() : Just(m.slice(0, -1));
        }
      }
      throw new TypeError("init: Argument must be an Array, String, or List");
    }
    module.exports = init;
  }
});

// node_modules/crocks/pointfree/last.js
var require_last = __commonJS({
  "node_modules/crocks/pointfree/last.js"(exports, module) {
    var cloneIterable = require_cloneIterable();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isIterable = require_isIterable();
    var isString = require_isString();
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    function last(m) {
      if (m && isFunction(m.last)) {
        return m.last();
      }
      if (isArray(m) || isString(m)) {
        return !m.length ? Nothing() : Just(m[m.length - 1]);
      }
      if (isIterable(m)) {
        var cloned = cloneIterable(m);
        var iterator = cloned[Symbol.iterator]();
        var curr = iterator.next();
        if (curr.done) {
          return Nothing();
        }
        var val;
        while (!curr.done) {
          val = curr.value;
          curr = iterator.next();
        }
        return Just(val);
      }
      throw new TypeError("last: Argument must be a List, String, or Iterable");
    }
    module.exports = last;
  }
});

// node_modules/crocks/pointfree/map.js
var require_map = __commonJS({
  "node_modules/crocks/pointfree/map.js"(exports, module) {
    var compose = require_compose();
    var curry = require_curry();
    var isArray = require_isArray();
    var isObject = require_isObject();
    var isFunction = require_isFunction();
    var isFunctor = require_isFunctor();
    var array = require_array();
    var object = require_object();
    var fl = require_flNames();
    function map(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError("map: Function required for first argument");
      }
      if (isFunction(m)) {
        return compose(fn, m);
      }
      if (isArray(m)) {
        return array.map(fn, m);
      }
      if (m && isFunctor(m)) {
        return (m[fl.map] || m.map).call(m, fn);
      }
      if (isObject(m)) {
        return object.map(fn, m);
      }
      throw new TypeError("map: Object, Function or Functor of the same type required for second argument");
    }
    module.exports = curry(map);
  }
});

// node_modules/crocks/pointfree/merge.js
var require_merge = __commonJS({
  "node_modules/crocks/pointfree/merge.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function merge(fn, m) {
      if (!isFunction(fn)) {
        throw new TypeError("merge: Function required for first argument");
      }
      if (!(m && isFunction(m.merge))) {
        throw new TypeError("merge: Pair or Tuple required for second argument");
      }
      return m.merge(fn);
    }
    module.exports = curry(merge);
  }
});

// node_modules/crocks/pointfree/option.js
var require_option = __commonJS({
  "node_modules/crocks/pointfree/option.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function option(x, m) {
      if (!(m && isFunction(m.option))) {
        throw new TypeError("option: Last argument must be a Maybe, First or Last");
      }
      return m.option(x);
    }
    module.exports = curry(option);
  }
});

// node_modules/crocks/pointfree/promap.js
var require_promap = __commonJS({
  "node_modules/crocks/pointfree/promap.js"(exports, module) {
    var compose = require_compose();
    var curry = require_curry();
    var fl = require_flNames();
    var isFunction = require_isFunction();
    var isProfunctor = require_isProfunctor();
    function promap(l, r, m) {
      if (!(isFunction(l) && isFunction(r))) {
        throw new TypeError(
          "promap: Functions required for first two arguments"
        );
      }
      if (isFunction(m)) {
        return compose(compose(r, m), l);
      }
      if (isProfunctor(m)) {
        return (m[fl.promap] || m.promap).call(m, l, r);
      }
      throw new TypeError(
        "promap: Function or Profunctor required for third argument"
      );
    }
    module.exports = curry(promap);
  }
});

// node_modules/crocks/pointfree/reduce.js
var require_reduce = __commonJS({
  "node_modules/crocks/pointfree/reduce.js"(exports, module) {
    var curry = require_curry();
    var isFoldable = require_isFoldable();
    var isFunction = require_isFunction();
    var fl = require_flNames();
    function reduce(fn, init, m) {
      if (!isFunction(fn)) {
        throw new TypeError(
          "reduce: Function required for first argument"
        );
      }
      if (!isFoldable(m)) {
        throw new TypeError(
          "reduce: Foldable required for third argument"
        );
      }
      return (m[fl.reduce] || m.reduce).call(m, fn, init);
    }
    module.exports = curry(reduce);
  }
});

// node_modules/crocks/pointfree/reduceRight.js
var require_reduceRight = __commonJS({
  "node_modules/crocks/pointfree/reduceRight.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function reduceRight(fn, init, m) {
      if (!isFunction(fn)) {
        throw new TypeError("reduceRight: Function required for first argument");
      } else if (!(m && isFunction(m.reduceRight))) {
        throw new TypeError("reduceRight: Right Foldable required for third argument");
      }
      return m.reduceRight(fn, init);
    }
    module.exports = curry(reduceRight);
  }
});

// node_modules/crocks/pointfree/reject.js
var require_reject = __commonJS({
  "node_modules/crocks/pointfree/reject.js"(exports, module) {
    var curry = require_curry();
    var isArray = require_isArray();
    var isPredOrFunc = require_isPredOrFunc();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var object = require_object();
    var predOrFunc = require_predOrFunc();
    var not = function(fn) {
      return function(x) {
        return !fn(x);
      };
    };
    function reject(pred, m) {
      if (!isPredOrFunc(pred)) {
        throw new TypeError(
          "reject: Pred or predicate function required for first argument"
        );
      }
      var fn = function(x) {
        return predOrFunc(pred, x);
      };
      if (m && isFunction(m.reject)) {
        return m.reject(fn);
      }
      if (isArray(m)) {
        return m.filter(not(fn));
      }
      if (isObject(m)) {
        return object.filter(not(fn), m);
      }
      throw new TypeError("reject: Foldable or Object required for second argument");
    }
    module.exports = curry(reject);
  }
});

// node_modules/crocks/pointfree/run.js
var require_run = __commonJS({
  "node_modules/crocks/pointfree/run.js"(exports, module) {
    var isFunction = require_isFunction();
    function run(m) {
      if (!(m && isFunction(m.run))) {
        throw new TypeError("run: IO required");
      }
      return m.run();
    }
    module.exports = run;
  }
});

// node_modules/crocks/pointfree/runWith.js
var require_runWith = __commonJS({
  "node_modules/crocks/pointfree/runWith.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function runWith(x, m) {
      if (!(m && isFunction(m.runWith))) {
        throw new TypeError("runWith: Arrow, Endo, Pred, Reader, Star or State required for second argument");
      }
      return m.runWith(x);
    }
    module.exports = curry(runWith);
  }
});

// node_modules/crocks/pointfree/second.js
var require_second = __commonJS({
  "node_modules/crocks/pointfree/second.js"(exports, module) {
    var Pair = require_types().proxy("Pair");
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var identity = function(x) {
      return x;
    };
    function second(m) {
      if (isFunction(m)) {
        return function(x) {
          if (!isSameType(Pair, x)) {
            throw new TypeError("second: Pair required as input");
          }
          return x.bimap(identity, m);
        };
      }
      if (m && isFunction(m.second)) {
        return m.second();
      }
      throw new TypeError("second: Strong Function or Profunctor required");
    }
    module.exports = second;
  }
});

// node_modules/crocks/pointfree/sequence.js
var require_sequence = __commonJS({
  "node_modules/crocks/pointfree/sequence.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isArray = require_isArray();
    var isApplicative = require_isApplicative();
    var isFunction = require_isFunction();
    function sequence(af, m) {
      if (!(isApplicative(af) || isFunction(af))) {
        throw new TypeError(
          "sequence: Applicative TypeRep or Apply returning function required for first argument"
        );
      }
      if (m && isFunction(m.sequence)) {
        return m.sequence(af);
      }
      if (isArray(m)) {
        return array.sequence(af, m);
      }
      throw new TypeError("sequence: Traversable or Array required for second argument");
    }
    module.exports = curry(sequence);
  }
});

// node_modules/crocks/pointfree/swap.js
var require_swap = __commonJS({
  "node_modules/crocks/pointfree/swap.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function swap(f, g, m) {
      if (!(isFunction(f) && isFunction(g))) {
        throw new TypeError(
          "swap: Function required for first two arguments"
        );
      }
      if (m && isFunction(m.swap)) {
        return m.swap(f, g);
      }
      throw new TypeError(
        "swap: Async, Either, Pair or Result required for third arguments"
      );
    }
    module.exports = curry(swap);
  }
});

// node_modules/crocks/pointfree/tail.js
var require_tail = __commonJS({
  "node_modules/crocks/pointfree/tail.js"(exports, module) {
    var isFunction = require_isFunction();
    var isNil = require_isNil();
    var ref = require_Maybe();
    var Nothing = ref.Nothing;
    var Just = ref.Just;
    function tail(m) {
      if (!isNil(m)) {
        if (isFunction(m.tail)) {
          return m.tail();
        }
        if (isFunction(m.slice)) {
          return m.length < 2 ? Nothing() : Just(m.slice(1));
        }
      }
      throw new TypeError("tail: Array, String or List required");
    }
    module.exports = tail;
  }
});

// node_modules/crocks/pointfree/traverse.js
var require_traverse = __commonJS({
  "node_modules/crocks/pointfree/traverse.js"(exports, module) {
    var array = require_array();
    var curry = require_curry();
    var isApplicative = require_isApplicative();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    function traverse(af, fn, m) {
      if (!(isApplicative(af) || isFunction(af))) {
        throw new TypeError(
          "traverse: Applicative TypeRep or Apply returning function required for first argument"
        );
      }
      if (!isFunction(fn)) {
        throw new TypeError(
          "traverse: Apply returning function required for second argument"
        );
      }
      if (m && isFunction(m.traverse)) {
        return m.traverse(af, fn);
      }
      if (isArray(m)) {
        return array.traverse(af, fn, m);
      }
      throw new TypeError("traverse: Traversable or Array required for third argument");
    }
    module.exports = curry(traverse);
  }
});

// node_modules/crocks/pointfree/valueOf.js
var require_valueOf = __commonJS({
  "node_modules/crocks/pointfree/valueOf.js"(exports, module) {
    var isNil = require_isNil();
    function valueOf(m) {
      if (isNil(m)) {
        return m;
      }
      return m.valueOf();
    }
    module.exports = valueOf;
  }
});

// node_modules/crocks/pointfree/index.js
var require_pointfree = __commonJS({
  "node_modules/crocks/pointfree/index.js"(exports, module) {
    module.exports = {
      alt: require_alt(),
      ap: require_ap(),
      bimap: require_bimap(),
      bichain: require_bichain(),
      both: require_both(),
      chain: require_chain(),
      coalesce: require_coalesce(),
      compareWith: require_compareWith(),
      concat: require_concat(),
      cons: require_cons(),
      contramap: require_contramap(),
      either: require_either(),
      empty: require_empty(),
      equals: require_equals2(),
      extend: require_extend(),
      filter: require_filter(),
      first: require_first(),
      fold: require_fold(),
      foldMap: require_foldMap(),
      head: require_head(),
      init: require_init(),
      last: require_last(),
      map: require_map(),
      merge: require_merge(),
      option: require_option(),
      promap: require_promap(),
      reduce: require_reduce(),
      reduceRight: require_reduceRight(),
      reject: require_reject(),
      run: require_run(),
      runWith: require_runWith(),
      second: require_second(),
      sequence: require_sequence(),
      swap: require_swap(),
      tail: require_tail(),
      traverse: require_traverse(),
      valueOf: require_valueOf()
    };
  }
});

// node_modules/crocks/State/evalWith.js
var require_evalWith = __commonJS({
  "node_modules/crocks/State/evalWith.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function evalWith(x, m) {
      if (!(m && isFunction(m.evalWith))) {
        throw new TypeError("evalWith: State required for second argument");
      }
      return m.evalWith(x);
    }
    module.exports = curry(evalWith);
  }
});

// node_modules/crocks/State/execWith.js
var require_execWith = __commonJS({
  "node_modules/crocks/State/execWith.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function execWith(x, m) {
      if (!(m && isFunction(m.execWith))) {
        throw new TypeError("execWith: State required for second argument");
      }
      return m.execWith(x);
    }
    module.exports = curry(execWith);
  }
});

// node_modules/crocks/Pair/fst.js
var require_fst = __commonJS({
  "node_modules/crocks/Pair/fst.js"(exports, module) {
    var isFunction = require_isFunction();
    function fst(m) {
      if (!(m && isFunction(m.fst))) {
        throw new TypeError("fst: Pair required");
      }
      return m.fst();
    }
    module.exports = fst;
  }
});

// node_modules/crocks/Writer/log.js
var require_log = __commonJS({
  "node_modules/crocks/Writer/log.js"(exports, module) {
    var isFunction = require_isFunction();
    function log(m) {
      if (!(m && isFunction(m.log))) {
        throw new TypeError("log: Writer required");
      }
      return m.log();
    }
    module.exports = log;
  }
});

// node_modules/crocks/Tuple/nmap.js
var require_nmap = __commonJS({
  "node_modules/crocks/Tuple/nmap.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isInteger = require_isInteger();
    var isSameType = require_isSameType();
    var Tuple = require_Tuple();
    var validTuple = function(n, m) {
      return isSameType(Tuple(n), m);
    };
    function runMap(m, fns) {
      var n = fns.length;
      if (!validTuple(n, m)) {
        throw new TypeError("nmap: " + n + "-Tuple required");
      }
      fns.forEach(function(fn) {
        if (!isFunction(fn)) {
          throw new TypeError("nmap: Functions required for all arguments");
        }
      });
      return m.mapAll.apply(m, fns);
    }
    var withLength = function(n, fn) {
      return Object.defineProperty(fn, "length", {
        value: n
      });
    };
    function nmap(n) {
      if (!(isInteger(n) && n >= 1)) {
        throw new TypeError("nmap: Integer required for first argument");
      }
      switch (n) {
        case 1:
          return function(a, m) {
            return runMap(m, [a]);
          };
        case 2:
          return function(a, b, m) {
            return runMap(m, [a, b]);
          };
        case 3:
          return function(a, b, c, m) {
            return runMap(m, [a, b, c]);
          };
        case 4:
          return function(a, b, c, d, m) {
            return runMap(m, [a, b, c, d]);
          };
        case 5:
          return function(a, b, c, d, e, m) {
            return runMap(m, [a, b, c, d, e]);
          };
        case 6:
          return function(a, b, c, d, e, f, m) {
            return runMap(m, [a, b, c, d, e, f]);
          };
        case 7:
          return function(a, b, c, d, e, f, g, m) {
            return runMap(m, [a, b, c, d, e, f, g]);
          };
        case 8:
          return function(a, b, c, d, e, f, g, h, m) {
            return runMap(m, [a, b, c, d, e, f, g, h]);
          };
        case 9:
          return function(a, b, c, d, e, f, g, h, i, m) {
            return runMap(m, [a, b, c, d, e, f, g, h, i]);
          };
        case 10:
          return function(a, b, c, d, e, f, g, h, i, j, m) {
            return runMap(m, [a, b, c, d, e, f, g, h, i, j]);
          };
        default:
          return withLength(n + 1, function() {
            var parts = [].slice.call(arguments);
            return runMap(parts[parts.length - 1], parts.slice(0, parts.length - 1));
          });
      }
    }
    module.exports = curry(nmap);
  }
});

// node_modules/crocks/Tuple/project.js
var require_project = __commonJS({
  "node_modules/crocks/Tuple/project.js"(exports, module) {
    var isFunction = require_isFunction();
    var curry = require_curry();
    function project(index, m) {
      if (!(m && isFunction(m.project))) {
        throw new TypeError("project: Tuple required");
      }
      return m.project(index);
    }
    module.exports = curry(project);
  }
});

// node_modules/crocks/Async/race.js
var require_race = __commonJS({
  "node_modules/crocks/Async/race.js"(exports, module) {
    var curry = require_curry();
    var isSameType = require_isSameType();
    var Async = require_types().proxy("Async");
    function race(m, a) {
      if (!(isSameType(m, a) && isSameType(Async, m))) {
        throw new TypeError("race: Both arguments must be Asyncs");
      }
      return a.race(m);
    }
    module.exports = curry(race);
  }
});

// node_modules/crocks/Writer/read.js
var require_read = __commonJS({
  "node_modules/crocks/Writer/read.js"(exports, module) {
    var isFunction = require_isFunction();
    function read(m) {
      if (!(m && isFunction(m.read))) {
        throw new TypeError("read: Writer required");
      }
      return m.read();
    }
    module.exports = read;
  }
});

// node_modules/crocks/Pair/snd.js
var require_snd = __commonJS({
  "node_modules/crocks/Pair/snd.js"(exports, module) {
    var isFunction = require_isFunction();
    function snd(m) {
      if (!(m && isFunction(m.snd))) {
        throw new TypeError("snd: Pair required");
      }
      return m.snd();
    }
    module.exports = snd;
  }
});

// node_modules/crocks/List/arrayToList.js
var require_arrayToList = __commonJS({
  "node_modules/crocks/List/arrayToList.js"(exports, module) {
    var List = require_List2();
    var curry = require_curry();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    function arrayToList(array) {
      if (isArray(array)) {
        return List.fromArray(array);
      } else if (isFunction(array)) {
        return function(x) {
          var g = array(x);
          if (!isArray(g)) {
            throw new TypeError("arrayToList: Array returning function required");
          }
          return List.fromArray(g);
        };
      }
      throw new TypeError("arrayToList: Array or Array returning function required");
    }
    module.exports = curry(arrayToList);
  }
});

// node_modules/crocks/Async/asyncToPromise.js
var require_asyncToPromise = __commonJS({
  "node_modules/crocks/Async/asyncToPromise.js"(exports, module) {
    var curry = require_curry();
    var isSameType = require_isSameType();
    var isFunction = require_isFunction();
    var Async = require_types().proxy("Async");
    var toPromise = function(m) {
      if (!isSameType(Async, m)) {
        throw new TypeError("asyncToPromise: Async or a function returning an Async required");
      }
      return m.toPromise();
    };
    function asyncToPromise(m) {
      return isFunction(m) ? function(x) {
        return toPromise(m(x));
      } : toPromise(m);
    }
    module.exports = curry(asyncToPromise);
  }
});

// node_modules/crocks/Async/eitherToAsync.js
var require_eitherToAsync = __commonJS({
  "node_modules/crocks/Async/eitherToAsync.js"(exports, module) {
    var Async = require_Async();
    var Either = require_types().proxy("Either");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(Async.Rejected, Async.Resolved);
    };
    function eitherToAsync(either) {
      if (isFunction(either)) {
        return function(x) {
          var m = either(x);
          if (!isSameType(Either, m)) {
            throw new TypeError("eitherToAsync: Either returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Either, either)) {
        return applyTransform(either);
      }
      throw new TypeError("eitherToAsync: Either or Either returning function required");
    }
    module.exports = curry(eitherToAsync);
  }
});

// node_modules/crocks/First/eitherToFirst.js
var require_eitherToFirst = __commonJS({
  "node_modules/crocks/First/eitherToFirst.js"(exports, module) {
    var First = require_First();
    var Either = require_types().proxy("Either");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(First.empty, First);
    };
    function eitherToFirst(either) {
      if (isFunction(either)) {
        return function(x) {
          var m = either(x);
          if (!isSameType(Either, m)) {
            throw new TypeError("eitherToFirst: Either returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Either, either)) {
        return applyTransform(either);
      }
      throw new TypeError("eitherToFirst: Either or Either returning function required");
    }
    module.exports = curry(eitherToFirst);
  }
});

// node_modules/crocks/Last/eitherToLast.js
var require_eitherToLast = __commonJS({
  "node_modules/crocks/Last/eitherToLast.js"(exports, module) {
    var Last = require_Last();
    var Either = require_types().proxy("Either");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(Last.empty, Last);
    };
    function eitherToLast(either) {
      if (isFunction(either)) {
        return function(x) {
          var m = either(x);
          if (!isSameType(Either, m)) {
            throw new TypeError("eitherToLast: Either returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Either, either)) {
        return applyTransform(either);
      }
      throw new TypeError("eitherToLast: Either or Either returning function required");
    }
    module.exports = curry(eitherToLast);
  }
});

// node_modules/crocks/Maybe/eitherToMaybe.js
var require_eitherToMaybe = __commonJS({
  "node_modules/crocks/Maybe/eitherToMaybe.js"(exports, module) {
    var Maybe = require_Maybe2();
    var Either = require_types().proxy("Either");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(Maybe.Nothing, Maybe.Just);
    };
    function eitherToMaybe(either) {
      if (isFunction(either)) {
        return function(x) {
          var m = either(x);
          if (!isSameType(Either, m)) {
            throw new TypeError("eitherToMaybe: Either returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Either, either)) {
        return applyTransform(either);
      }
      throw new TypeError("eitherToMaybe: Either or Either returning function required");
    }
    module.exports = curry(eitherToMaybe);
  }
});

// node_modules/crocks/Result/eitherToResult.js
var require_eitherToResult = __commonJS({
  "node_modules/crocks/Result/eitherToResult.js"(exports, module) {
    var Result = require_Result();
    var Either = require_types().proxy("Either");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(Result.Err, Result.Ok);
    };
    function eitherToResult(either) {
      if (isFunction(either)) {
        return function(x) {
          var m = either(x);
          if (!isSameType(Either, m)) {
            throw new TypeError("eitherToResult: Either returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Either, either)) {
        return applyTransform(either);
      }
      throw new TypeError("eitherToResult: Either or Either returning function required");
    }
    module.exports = curry(eitherToResult);
  }
});

// node_modules/crocks/Async/firstToAsync.js
var require_firstToAsync = __commonJS({
  "node_modules/crocks/Async/firstToAsync.js"(exports, module) {
    var Async = require_Async();
    var First = require_types().proxy("First");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, first) {
      return first.valueOf().either(
        constant(Async.Rejected(left)),
        Async.Resolved
      );
    };
    function firstToAsync(left, first) {
      if (isFunction(first)) {
        return function(x) {
          var m = first(x);
          if (!isSameType(First, m)) {
            throw new TypeError("firstToAsync: First returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(First, first)) {
        return applyTransform(left, first);
      }
      throw new TypeError("firstToAsync: First or First returning function required for second argument");
    }
    module.exports = curry(firstToAsync);
  }
});

// node_modules/crocks/Either/firstToEither.js
var require_firstToEither = __commonJS({
  "node_modules/crocks/Either/firstToEither.js"(exports, module) {
    var Either = require_Either();
    var First = require_types().proxy("First");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, first) {
      return first.valueOf().either(
        constant(Either.Left(left)),
        Either.Right
      );
    };
    function firstToEither(left, first) {
      if (isFunction(first)) {
        return function(x) {
          var m = first(x);
          if (!isSameType(First, m)) {
            throw new TypeError("firstToEither: First returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(First, first)) {
        return applyTransform(left, first);
      }
      throw new TypeError("firstToEither: First or First returning function required for second argument");
    }
    module.exports = curry(firstToEither);
  }
});

// node_modules/crocks/Last/firstToLast.js
var require_firstToLast = __commonJS({
  "node_modules/crocks/Last/firstToLast.js"(exports, module) {
    var Last = require_Last();
    var First = require_types().proxy("First");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(first) {
      return Last(first.valueOf());
    };
    function firstToLast(first) {
      if (isFunction(first)) {
        return function(x) {
          var m = first(x);
          if (!isSameType(First, m)) {
            throw new TypeError("firstToLast: First returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(First, first)) {
        return applyTransform(first);
      }
      throw new TypeError("firstToLast: First or First returning function required");
    }
    module.exports = curry(firstToLast);
  }
});

// node_modules/crocks/Maybe/firstToMaybe.js
var require_firstToMaybe = __commonJS({
  "node_modules/crocks/Maybe/firstToMaybe.js"(exports, module) {
    var First = require_types().proxy("First");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(first) {
      return first.valueOf();
    };
    function firstToMaybe(first) {
      if (isFunction(first)) {
        return function(x) {
          var m = first(x);
          if (!isSameType(First, m)) {
            throw new TypeError("firstToMaybe: First returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(First, first)) {
        return applyTransform(first);
      }
      throw new TypeError("firstToMaybe: First or First returning function required");
    }
    module.exports = curry(firstToMaybe);
  }
});

// node_modules/crocks/Result/firstToResult.js
var require_firstToResult = __commonJS({
  "node_modules/crocks/Result/firstToResult.js"(exports, module) {
    var Result = require_Result();
    var First = require_types().proxy("First");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, first) {
      return first.valueOf().either(
        constant(Result.Err(left)),
        Result.Ok
      );
    };
    function firstToResult(left, first) {
      if (isFunction(first)) {
        return function(x) {
          var m = first(x);
          if (!isSameType(First, m)) {
            throw new TypeError("firstToResult: First returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(First, first)) {
        return applyTransform(left, first);
      }
      throw new TypeError("firstToResult: First or First returning function required for second argument");
    }
    module.exports = curry(firstToResult);
  }
});

// node_modules/crocks/Async/lastToAsync.js
var require_lastToAsync = __commonJS({
  "node_modules/crocks/Async/lastToAsync.js"(exports, module) {
    var Async = require_Async();
    var Last = require_types().proxy("Last");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, last) {
      return last.valueOf().either(
        constant(Async.Rejected(left)),
        Async.Resolved
      );
    };
    function lastToAsync(left, last) {
      if (isFunction(last)) {
        return function(x) {
          var m = last(x);
          if (!isSameType(Last, m)) {
            throw new TypeError("lastToAsync: Last returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Last, last)) {
        return applyTransform(left, last);
      }
      throw new TypeError("lastToAsync: Last or Last returning function required for second argument");
    }
    module.exports = curry(lastToAsync);
  }
});

// node_modules/crocks/Either/lastToEither.js
var require_lastToEither = __commonJS({
  "node_modules/crocks/Either/lastToEither.js"(exports, module) {
    var Either = require_Either();
    var Last = require_types().proxy("Last");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, last) {
      return last.valueOf().either(
        constant(Either.Left(left)),
        Either.Right
      );
    };
    function lastToEither(left, last) {
      if (isFunction(last)) {
        return function(x) {
          var m = last(x);
          if (!isSameType(Last, m)) {
            throw new TypeError("lastToEither: Last returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Last, last)) {
        return applyTransform(left, last);
      }
      throw new TypeError("lastToEither: Last or Last returning function required for second argument");
    }
    module.exports = curry(lastToEither);
  }
});

// node_modules/crocks/First/lastToFirst.js
var require_lastToFirst = __commonJS({
  "node_modules/crocks/First/lastToFirst.js"(exports, module) {
    var First = require_First();
    var Last = require_types().proxy("Last");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(last) {
      return First(last.valueOf());
    };
    function lastToFirst(last) {
      if (isFunction(last)) {
        return function(x) {
          var m = last(x);
          if (!isSameType(Last, m)) {
            throw new TypeError("lastToFirst: Last returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Last, last)) {
        return applyTransform(last);
      }
      throw new TypeError("lastToFirst: Last or Last returning function required");
    }
    module.exports = curry(lastToFirst);
  }
});

// node_modules/crocks/Maybe/lastToMaybe.js
var require_lastToMaybe = __commonJS({
  "node_modules/crocks/Maybe/lastToMaybe.js"(exports, module) {
    var Last = require_types().proxy("Last");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(last) {
      return last.valueOf();
    };
    function lastToMaybe(last) {
      if (isFunction(last)) {
        return function(x) {
          var m = last(x);
          if (!isSameType(Last, m)) {
            throw new TypeError("lastToMaybe: Last returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Last, last)) {
        return applyTransform(last);
      }
      throw new TypeError("lastToMaybe: Last or Last returning function required");
    }
    module.exports = curry(lastToMaybe);
  }
});

// node_modules/crocks/Result/lastToResult.js
var require_lastToResult = __commonJS({
  "node_modules/crocks/Result/lastToResult.js"(exports, module) {
    var Result = require_Result();
    var Last = require_types().proxy("Last");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, last) {
      return last.valueOf().either(
        constant(Result.Err(left)),
        Result.Ok
      );
    };
    function lastToResult(left, last) {
      if (isFunction(last)) {
        return function(x) {
          var m = last(x);
          if (!isSameType(Last, m)) {
            throw new TypeError("lastToResult: Last returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Last, last)) {
        return applyTransform(left, last);
      }
      throw new TypeError("lastToResult: Last or Last returning function required for second argument");
    }
    module.exports = curry(lastToResult);
  }
});

// node_modules/crocks/List/listToArray.js
var require_listToArray = __commonJS({
  "node_modules/crocks/List/listToArray.js"(exports, module) {
    var List = require_List2();
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    function listToArray(list) {
      if (isFunction(list)) {
        return function(x) {
          var m = list(x);
          if (!isSameType(List, m)) {
            throw new TypeError("listToArray: List returning function required");
          }
          return m.toArray();
        };
      }
      if (isSameType(List, list)) {
        return list.toArray();
      }
      throw new TypeError("listToArray: List or List returning function required");
    }
    module.exports = curry(listToArray);
  }
});

// node_modules/crocks/Maybe/maybeToArray.js
var require_maybeToArray = __commonJS({
  "node_modules/crocks/Maybe/maybeToArray.js"(exports, module) {
    var Maybe = require_Maybe2();
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(maybe) {
      return maybe.either(function() {
        return [];
      }, function(x) {
        return [x];
      });
    };
    var err = "maybeToArray: Argument must be a Maybe instanstace or a Maybe returning function";
    function maybeToArray(maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError(err);
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(maybe);
      }
      throw new TypeError(err);
    }
    module.exports = curry(maybeToArray);
  }
});

// node_modules/crocks/Async/maybeToAsync.js
var require_maybeToAsync = __commonJS({
  "node_modules/crocks/Async/maybeToAsync.js"(exports, module) {
    var Async = require_Async();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, maybe) {
      return maybe.either(
        constant(Async.Rejected(left)),
        Async.Resolved
      );
    };
    function maybeToAsync(left, maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("maybeToAsync: Maybe returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(left, maybe);
      }
      throw new TypeError("maybeToAsync: Maybe or Maybe returning function required for second argument");
    }
    module.exports = curry(maybeToAsync);
  }
});

// node_modules/crocks/Either/maybeToEither.js
var require_maybeToEither = __commonJS({
  "node_modules/crocks/Either/maybeToEither.js"(exports, module) {
    var Either = require_Either();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, maybe) {
      return maybe.either(
        constant(Either.Left(left)),
        Either.Right
      );
    };
    function maybeToEither(left, maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("maybeToEither: Maybe returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(left, maybe);
      }
      throw new TypeError("maybeToEither: Maybe or Maybe returning function required for second argument");
    }
    module.exports = curry(maybeToEither);
  }
});

// node_modules/crocks/First/maybeToFirst.js
var require_maybeToFirst = __commonJS({
  "node_modules/crocks/First/maybeToFirst.js"(exports, module) {
    var First = require_First();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(maybe) {
      return First(maybe);
    };
    function maybeToFirst(maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("maybeToFirst: Maybe returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(maybe);
      }
      throw new TypeError("maybeToFirst: Maybe or Maybe returning function required");
    }
    module.exports = curry(maybeToFirst);
  }
});

// node_modules/crocks/Last/maybeToLast.js
var require_maybeToLast = __commonJS({
  "node_modules/crocks/Last/maybeToLast.js"(exports, module) {
    var Last = require_Last();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(maybe) {
      return Last(maybe);
    };
    function maybeToLast(maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("maybeToLast: Maybe returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(maybe);
      }
      throw new TypeError("maybeToLast: Maybe or Maybe returning function required");
    }
    module.exports = curry(maybeToLast);
  }
});

// node_modules/crocks/List/maybeToList.js
var require_maybeToList = __commonJS({
  "node_modules/crocks/List/maybeToList.js"(exports, module) {
    var List = require_List2();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(maybe) {
      return maybe.either(
        List.empty,
        List.of
      );
    };
    var err = "maybeToList: Argument must be a Maybe instanstace or a Maybe returning function";
    function maybeToList(maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError(err);
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(maybe);
      }
      throw new TypeError(err);
    }
    module.exports = curry(maybeToList);
  }
});

// node_modules/crocks/Result/maybeToResult.js
var require_maybeToResult = __commonJS({
  "node_modules/crocks/Result/maybeToResult.js"(exports, module) {
    var Result = require_Result();
    var Maybe = require_types().proxy("Maybe");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var constant = function(x) {
      return function() {
        return x;
      };
    };
    var applyTransform = function(left, maybe) {
      return maybe.either(
        constant(Result.Err(left)),
        Result.Ok
      );
    };
    function maybeToResult(left, maybe) {
      if (isFunction(maybe)) {
        return function(x) {
          var m = maybe(x);
          if (!isSameType(Maybe, m)) {
            throw new TypeError("maybeToResult: Maybe returning function required for second argument");
          }
          return applyTransform(left, m);
        };
      }
      if (isSameType(Maybe, maybe)) {
        return applyTransform(left, maybe);
      }
      throw new TypeError("maybeToResult: Maybe or Maybe returning function required for second argument");
    }
    module.exports = curry(maybeToResult);
  }
});

// node_modules/crocks/Async/resultToAsync.js
var require_resultToAsync = __commonJS({
  "node_modules/crocks/Async/resultToAsync.js"(exports, module) {
    var Async = require_Async();
    var Result = require_types().proxy("Result");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(either) {
      return either.either(Async.Rejected, Async.Resolved);
    };
    function resultToAsync(result) {
      if (isFunction(result)) {
        return function(x) {
          var m = result(x);
          if (!isSameType(Result, m)) {
            throw new TypeError("resultToAsync: Result returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Result, result)) {
        return applyTransform(result);
      }
      throw new TypeError("resultToAsync: Result or Result returning function required");
    }
    module.exports = curry(resultToAsync);
  }
});

// node_modules/crocks/Either/resultToEither.js
var require_resultToEither = __commonJS({
  "node_modules/crocks/Either/resultToEither.js"(exports, module) {
    var Either = require_Either();
    var Result = require_types().proxy("Result");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(result) {
      return result.either(Either.Left, Either.Right);
    };
    function resultToEither(result) {
      if (isFunction(result)) {
        return function(x) {
          var m = result(x);
          if (!isSameType(Result, m)) {
            throw new TypeError("resultToEither: Result returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Result, result)) {
        return applyTransform(result);
      }
      throw new TypeError("resultToEither: Result or Result returning function required");
    }
    module.exports = curry(resultToEither);
  }
});

// node_modules/crocks/First/resultToFirst.js
var require_resultToFirst = __commonJS({
  "node_modules/crocks/First/resultToFirst.js"(exports, module) {
    var First = require_First();
    var Result = require_types().proxy("Result");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(result) {
      return result.either(First.empty, First);
    };
    function resultToFirst(result) {
      if (isFunction(result)) {
        return function(x) {
          var m = result(x);
          if (!isSameType(Result, m)) {
            throw new TypeError("resultToFirst: Result returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Result, result)) {
        return applyTransform(result);
      }
      throw new TypeError("resultToFirst: Result or Result returning function required");
    }
    module.exports = curry(resultToFirst);
  }
});

// node_modules/crocks/Last/resultToLast.js
var require_resultToLast = __commonJS({
  "node_modules/crocks/Last/resultToLast.js"(exports, module) {
    var Last = require_Last();
    var Result = require_types().proxy("Result");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(result) {
      return result.either(Last.empty, Last);
    };
    function resultToLast(result) {
      if (isFunction(result)) {
        return function(x) {
          var m = result(x);
          if (!isSameType(Result, m)) {
            throw new TypeError("resultToLast: Result returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Result, result)) {
        return applyTransform(result);
      }
      throw new TypeError("resultToLast: Result or Result returning function required");
    }
    module.exports = curry(resultToLast);
  }
});

// node_modules/crocks/Maybe/resultToMaybe.js
var require_resultToMaybe = __commonJS({
  "node_modules/crocks/Maybe/resultToMaybe.js"(exports, module) {
    var Maybe = require_Maybe2();
    var Result = require_types().proxy("Result");
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isSameType = require_isSameType();
    var applyTransform = function(result) {
      return result.either(Maybe.Nothing, Maybe.Just);
    };
    function resultToMaybe(result) {
      if (isFunction(result)) {
        return function(x) {
          var m = result(x);
          if (!isSameType(Result, m)) {
            throw new TypeError("resultToMaybe: Result returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isSameType(Result, result)) {
        return applyTransform(result);
      }
      throw new TypeError("resultToMaybe: Result or Result returning function required");
    }
    module.exports = curry(resultToMaybe);
  }
});

// node_modules/crocks/Tuple/tupleToArray.js
var require_tupleToArray = __commonJS({
  "node_modules/crocks/Tuple/tupleToArray.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    function tupleToArray(tuple) {
      if (isFunction(tuple)) {
        return function(x) {
          var m = tuple(x);
          if (!isFunction(m.tupleLength)) {
            throw new TypeError("tupleToArray: Tuple returning function required");
          }
          return m.toArray();
        };
      }
      if (isFunction(tuple.tupleLength)) {
        return tuple.toArray();
      }
      throw new TypeError("tupleToArray: Tuple or Tuple returning function required");
    }
    module.exports = curry(tupleToArray);
  }
});

// node_modules/crocks/Pair/writerToPair.js
var require_writerToPair = __commonJS({
  "node_modules/crocks/Pair/writerToPair.js"(exports, module) {
    var curry = require_curry();
    var isFunction = require_isFunction();
    var isWriter = function(x) {
      return !!x && isFunction(x.read);
    };
    var applyTransform = function(w) {
      return w.read();
    };
    function writerToPair(writer) {
      if (isFunction(writer)) {
        return function(x) {
          var m = writer(x);
          if (!isWriter(m)) {
            throw new TypeError("writerToPair: Writer returning function required");
          }
          return applyTransform(m);
        };
      }
      if (isWriter(writer)) {
        return applyTransform(writer);
      }
      throw new TypeError("writerToPair: Writer or Writer returning function required");
    }
    module.exports = curry(writerToPair);
  }
});

// node_modules/crocks/index.js
var require_crocks = __commonJS({
  "node_modules/crocks/index.js"(exports, module) {
    var combinators = require_combinators();
    var logic = require_logic();
    var predicates = require_predicates();
    var crocks = {
      Arrow: require_Arrow(),
      Async: require_Async(),
      Const: require_Const(),
      Either: require_Either(),
      Equiv: require_Equiv(),
      Identity: require_Identity(),
      IO: require_IO(),
      List: require_List2(),
      Maybe: require_Maybe2(),
      Pair: require_Pair2(),
      Pred: require_Pred2(),
      Reader: require_Reader(),
      ReaderT: require_ReaderT(),
      Result: require_Result(),
      Star: require_Star(),
      State: require_State(),
      Tuple: require_Tuple(),
      Unit: require_Unit2(),
      Writer: require_Writer()
    };
    var helpers = Object.assign(
      {},
      require_helpers(),
      {
        branch: require_branch(),
        fanout: require_fanout(),
        find: require_find(),
        getPath: require_getPath(),
        getProp: require_getProp(),
        prop: require_prop(),
        propPath: require_propPath(),
        safe: require_safe(),
        safeAfter: require_safeAfter(),
        safeLift: require_safeLift(),
        toPairs: require_toPairs(),
        tryCatch: require_tryCatch()
      }
    );
    var monoids = {
      All: require_All(),
      Any: require_Any(),
      Assign: require_Assign(),
      Endo: require_Endo(),
      First: require_First(),
      Last: require_Last(),
      Max: require_Max(),
      Min: require_Min(),
      Prod: require_Prod(),
      Sum: require_Sum()
    };
    var pointfree = Object.assign(
      {},
      require_pointfree(),
      {
        evalWith: require_evalWith(),
        execWith: require_execWith(),
        fst: require_fst(),
        log: require_log(),
        nmap: require_nmap(),
        project: require_project(),
        race: require_race(),
        read: require_read(),
        snd: require_snd()
      }
    );
    var transforms = {
      arrayToList: require_arrayToList(),
      asyncToPromise: require_asyncToPromise(),
      eitherToAsync: require_eitherToAsync(),
      eitherToFirst: require_eitherToFirst(),
      eitherToLast: require_eitherToLast(),
      eitherToMaybe: require_eitherToMaybe(),
      eitherToResult: require_eitherToResult(),
      firstToAsync: require_firstToAsync(),
      firstToEither: require_firstToEither(),
      firstToLast: require_firstToLast(),
      firstToMaybe: require_firstToMaybe(),
      firstToResult: require_firstToResult(),
      lastToAsync: require_lastToAsync(),
      lastToEither: require_lastToEither(),
      lastToFirst: require_lastToFirst(),
      lastToMaybe: require_lastToMaybe(),
      lastToResult: require_lastToResult(),
      listToArray: require_listToArray(),
      maybeToArray: require_maybeToArray(),
      maybeToAsync: require_maybeToAsync(),
      maybeToEither: require_maybeToEither(),
      maybeToFirst: require_maybeToFirst(),
      maybeToLast: require_maybeToLast(),
      maybeToList: require_maybeToList(),
      maybeToResult: require_maybeToResult(),
      resultToAsync: require_resultToAsync(),
      resultToEither: require_resultToEither(),
      resultToFirst: require_resultToFirst(),
      resultToLast: require_resultToLast(),
      resultToMaybe: require_resultToMaybe(),
      tupleToArray: require_tupleToArray(),
      writerToPair: require_writerToPair()
    };
    module.exports = Object.assign(
      {},
      combinators,
      crocks,
      helpers,
      logic,
      monoids,
      pointfree,
      predicates,
      transforms
    );
  }
});

// dep:crocks
var crocks_default = require_crocks();
export {
  crocks_default as default
};
/** @license ISC License (c) copyright 2016 original and current authors */
/** @license ISC License (c) copyright 2017 original and current authors */
/** @license ISC License (c) copyright 2018 original and current authors */
/** @license ISC License (c) copyright 2019 original and current authors */
//# sourceMappingURL=crocks.js.map
